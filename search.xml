<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Spring]Filter, Interceptor, AOP]]></title>
    <url>%2F2019%2F03%2F17%2FSpring-FilterInterceptorAOP%2F</url>
    <content type="text"><![CDATA[Filter, Iterceptor, AOP의 차이점 및 정리스프링으로 웹 개발을 하다보면 Filter, Interceptor, AOP를 이용해 전/후 처리를 할 수 있다, 셋 다 비슷한 기능을 가지고 있지만 시점이나 적용하는 방식이 다르다. ) Filter말그대로 요청과 응답을 거른뒤 정제하는 역할을 한다. 서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러가지 체크를 수행할 수 있다. 또한 자원의 처리가 끝난 후 응답내용에 대해서도 변경하는 처리를 할 수가 있다. 보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS방어 등의 요청에 대한 처리로 사용된다. Filter 메서드init() - 필터 인스턴스 초기화 doFilter() - 전/후 처리 destroy() - 필터 인스턴스 종료 Interceptor필터는 스프링과 무관하게 지정된 자원에 대해 동작한다. 스프링은 DistpatcherServlet으로부터 시작되므로 필터는 스프링 컨텍스트 외부에 존재하게 된다. 하지만 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트 내부에 존재하게된다. 그리고 스프링 내의 모든 객체(bean) 접근이 가능하다. 인터셉터는 여러 개를 사용할 수 있고 로그인 체크, 권한체크, 프로그램 실행시간 계산작업 로그확인, 업로드 파일처리등에 사용된다. Interceptor 메서드preHandler() - 컨트롤러 메서드가 실행되기 전 postHanler() - 컨트롤러 메서드 실행직 후 view페이지 렌더링 되기 전 afterCompletion() - view페이지가 렌더링 되고 난 후 AOP객체 지향의 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다. 주로 ‘로깅’, ‘트랜잭션’, ‘에러 처리’등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용합니다. Interceptor나 Filter와는 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다. Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 애노테이션 등 다양한 방법으로 대상을 지정할 수 있다. AOP의 포인트컷@Before: 대상 메서드의 수행 전 @After: 대상 메서드의 수행 후 @After-returning: 대상 메서드의 정상적인 수행 후 @After-throwing: 예외발생 후 @Around: 대상 메서드의 수행 전/후 정리 구분 Filter Interceptor AOP 실행위치 서블릿 (Dispatcher Servlet 바깥) 서블릿 (Dispatcher Servlet 안쪽) 메서드 실행순서 1 2 3 설정파일 위치 web.xml xml,java xml,java 실행 메소드 init (필터 인스턴스 초기화)doFilter (전/후 처리)destroy (필터 인스턴스 종료) preHandler (컨트롤러 실행 전)postHandler (컨트롤러 실행 후)afterCompletion (view 페이지 렌더링 후) pointcut (포인트컷)(@after, @before, @around 등)]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
        <tag>Filter</tag>
        <tag>Interceptor</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring]Dispatcher-Servlet이란]]></title>
    <url>%2F2019%2F03%2F16%2FSpring-dispatcherServlet%2F</url>
    <content type="text"><![CDATA[Dispatcher-Servlet 이란 Servlet Container에서 HTTP프로토콜을 통해 들어오는 모든 요청을 프레젠테이션 계층의 제일앞에 둬서 중앙집중식으로 처리해주는 프론트 컨트롤러(Front Controller) 클라이언트로부터 어떠한 요청이 오면 Tomcat(톰캣)과 같은 서블릿컨테이너가 요청을 받는데,이때 제일 앞에서 서버로 들어오는 모든 요청을 처리하는 프론트 컨트롤러를 Spring에서 정의하였고,이를 DispatcherServlet이라고 한다. 그래서 공통처리 작업을 DispatcherServlet이 처리한 후, 적절한 세부 컨트롤러로 작업을 위임한다. Dispatcher-Servlet의 처리과정 먼저 DispatcherServlet이 요청을 받으면 그 요청을 처리할 수 있는 Handler의 이름을 HandlerMapping에게 물어본다. HandlerMapping은 요청 URL을 보고 Handler를 판단하고, 또한 Handler 실행 전에 전처리, 후처리로 실행해야 할 인터셉터 목록을 결정한다. DispatcherServlet은 제어권을 Handler로 전달한다. Handler는 응답에 필요한 서비스를 호출하고 응답에서 렌더링해야 하는 View Name을 판단해서 DispatcherServlet에 전송한다. DispatcherServlet은 논리적인 View Name을 ViewResolver에 전달해서 응답에 필요한 View를 생성할 수 있도록 한다. 그 후 해당 View에 Model과 컨트롤러를 전달해서 응답을 생성한다. 이렇게 생성한 응답을 클라이언트에게 반환한다.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
        <tag>DispatcherServlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm]프로그래머스-단어 변환]]></title>
    <url>%2F2019%2F03%2F15%2FAlgorithm-wordConversion%2F</url>
    <content type="text"><![CDATA[단어 변환문제 설명두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다. 한 번에 한 개의 알파벳만 바꿀 수 있습니다. words에 있는 단어로만 변환할 수 있습니다.예를 들어 begin이 hit, target가 cog, words가 [hot,dot,dog,lot,log,cog]라면 hit -&gt; hot -&gt; dot -&gt; dog -&gt; cog와 같이 4단계를 거쳐 변환할 수 있습니다. 두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요. 제한사항 각 단어는 알파벳 소문자로만 이루어져 있습니다. 각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다. words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다. begin과 target은 같지 않습니다. 변환할 수 없는 경우에는 0를 return 합니다.소스 코드자바123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;class Solution &#123; public int solution(String begin, String target, String[] words) &#123; int[] countarray = new int[words.length]; //words배열 안의 단어까지 도달하는 카운트를 저장하는 배열 boolean[][] array = new boolean[words.length][words.length]; //각 단어에서 단어로 변환 될수 있는지를 나타내기 위한 배열 int targetindex=-1; //최종으로 변환되어야 하는 단어의 인덱스를 저장하기 위한 변수 Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;words.length;i++)&#123; //시작 단어에서 변환 가능한 단어들을 찾기위한 반복문 int count =0; for(int j=0;j&lt;begin.length();j++)&#123; if(count==2)break; if(words[i].charAt(j)!=begin.charAt(j))&#123; count++; &#125; &#125; if(count==1)&#123; //변환이 가능하면 큐에 집어 넣고 도달하는 카운트를 1로 저장 queue.offer(i); countarray[i]++; &#125; if(words[i].equals(target))&#123; //단어가 최종 단어이면 인덱스를 저장 targetindex=i; &#125; &#125; if(targetindex==-1) return 0; //배열안에 최종 단어가 존재하지 않으면 0을 반환 for(int i=0; i&lt;words.length;i++)&#123; //단어에서 다른 단어로 변환이 가능 하는지 확인하는 반복문 for(int j=i+1;j&lt;words.length;j++)&#123; int count =0; for(int k=0;k&lt;begin.length();k++)&#123; if(count==2)break; if(words[i].charAt(k)!=words[j].charAt(k))count++; &#125; if(count==1)&#123; //i단어에서 j단어로 변환이 가능하면 array[i][j]를 true로 array[i][j]=true; array[j][i]=true;//방향성이 없기때문에 array[j][i]도 true로 &#125; &#125; &#125; while(!queue.isEmpty())&#123; //BFS시작 int index = queue.poll(); for(int i=0; i&lt;words.length;i++)&#123; if(countarray[i]==0 &amp;&amp;array[index][i])&#123; countarray[i]=countarray[index]+1; queue.offer(i); &#125; &#125; &#125; return countarray[targetindex]; &#125;&#125; 소스코드 설명단어간 변화 할수 있는지 charAt함수를 이용하여 한글자씩 비교 하였고 한개만 다른 경우에는 변화 할 수 있다 생각하여 배열에 양방향으로 true를 주었습니다. 배열을 만들고 큐를 이용하여 반복문을 돌려 BFS를 구현하였습니다. 이미 탐색한 문자열은 countarray를 이용하여 체크하며 해당 문자열이 몇번째로 탐색 되었는지 카운트를 입력하였으며 countarryay[targetindex]를 이용하여 목표 문자열은 몇번째로 탐색 되었는지 결과값을 리턴하였습니다.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>프로그래머스</tag>
        <tag>너비우선탐색</tag>
        <tag>BFS</tag>
        <tag>단어 변환</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm]프로그래머스-도둑질]]></title>
    <url>%2F2019%2F03%2F14%2FAlgorithm-%20thievery%2F</url>
    <content type="text"><![CDATA[도둑질문제 설명도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다. 각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다. 각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요. 제한사항이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다. money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다. 입출력 예 money return [1,2,3,1] 4 소스 코드자바123456789101112131415161718192021class Solution &#123; public int solution(int[] money) &#123; int answer = 0; int length = money.length; int[] dp =new int[length-1]; int[] dp2= new int[length]; dp[0]=money[0]; dp[1]=money[0]; dp2[0]=0; dp2[1]=money[1]; for(int i=2;i&lt;length-1;i++)&#123; dp[i]=Math.max(dp[i-2]+money[i],dp[i-1]); &#125; for(int i=2;i&lt;length;i++)&#123; dp2[i]=Math.max(dp2[i-2]+money[i],dp2[i-1]); &#125; return Math.max(dp[length-2],dp2[length-1]); &#125;&#125; 소스코드 설명값을 저장할 dp배열을 2개를 만들었습니다. 한개는 처음 집을 훔치는 경우이며 다른 한개는 처음 집을 훔치지 않는 경우 입니다. dp배열은 처음 집을 훔치기때문에 인접한 마지막 집은 훔칠수 없으므로 반복문은 length-1 전까지만 돌렸습니다. dp[0]과 dp[1]은 0번째 집부터 1번째 집까지 가장 많이 훔칠수 있는 금액인데 0번집을 훔치기때문에 1번째 집은 훔칠수없게되고 dp[1]까지의 가장큰 금액은 첫번째 집을 훔친 경우이므로 dp[0],dp[1]에는 0번 집의 돈을 넣어 줬습니다. 반복문을 돌면서 두번째 전의 최대 돈에 현재 번째 집의 돈을 합친것과 이전의 최대 돈을 비교하여 dp배열을 채웁니다. dp2의 경우는 0번째 집에서는 돈을 훔치지 않는 경우이며 0을 넣어주고 dp2[1]에는 1번째 집의 돈을 넣어주고 똑같은 방법으로 반복을 시킵니다. dp2는 첫번째 집에서는 돈을 훔치지 않으므로 반복문은 length까지 돌렸습니다. dp와 dp2의 마지막 값을 비교하여 더 큰값을 출력 하여 정답을 구하였습니다.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>프로그래머스</tag>
        <tag>동적계획법</tag>
        <tag>도둑질</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm]프로그래머스-정수 삼각형]]></title>
    <url>%2F2019%2F03%2F13%2FAlgorithm-triangle%2F</url>
    <content type="text"><![CDATA[정수 삼각형문제 설명 위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다. 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요. 제한사항삼각형의 높이는 1 이상 500 이하입니다. 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다. 입출력 예 triangle return [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] 30 출처 소스 코드자바123456789101112class Solution &#123; int answer=0; public int solution(int[][] triangle) &#123; for(int i =triangle.length-2;i&gt;=0;i--)&#123; for(int j=0;j&lt;triangle[i].length;j++)&#123; triangle[i][j]=triangle[i+1][j]&gt;triangle[i+1][j+1]?triangle[i][j]+triangle[i+1][j]: triangle[i][j]+ triangle[i+1][j+1]; &#125; &#125; return triangle[0][0]; &#125; &#125; 소스코드 설명처음에는 재귀함수를 통하여 모든 결과를 더하고 맨마지막 행에 도달했을 때 점수가 최대값보다 크면 최대값을 갱신하는 방법을 이용하였습니다. 문제가 원하는 방법이 아니듯 시간 초과로 실패 하였고 다른 방법을 생각하였습니다. 갈수 있는 길은 [i][j]일 경우 [i+1][j] or [i+1][j+1]이기 때문에 반대로 올라가는 방법을 생각하게 되었고 [i][j]에 [i+1][j] 과 [i+1][j+1] 더 큰값을 더해주면서 삼각형 맨 위까지 반복문을 돌리게 되면 triangle[0][0]에는 최대 값이 저장 됩니다.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>프로그래머스</tag>
        <tag>동적계획법</tag>
        <tag>정수삼각형</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-6.자바 가비지 컬렉터]]></title>
    <url>%2F2019%2F03%2F12%2FJava-garbagecollection%2F</url>
    <content type="text"><![CDATA[가비지 컬렉션쉽게 이야기해서 Java가 개발자 대신 사용하지 않는 객체를 자동으로 찾아 메모리에서 제거해줌으로써 메모리를 관리해주는 것이다. GC 대상이 되는 객체 모든 객체 참조가 null 인 경우 객체가 블럭 안에서 생성되고 블럭이 종료된 경우 부모 객체가 null이 된 경우, 자식 객체는 자동적으로 GC 대상이 된다. 객체가 Weak 참조만 가지고 있을 경우 객체가 Soft 참조이지만 메모리 부족이 발생한 경우 가비지 컬렉션 과정 - Generational Garbage CollectionGenerational Garbage Collection에서는 힙을 Young, Old or Tenured, Permanent Generation으로 나눈다. Young 영역 새롭게 생성한 객체의 대부분이 여기에 위치한다. 가득차게 되면 minor garbage collection이 일어난다. 대부분 객체가 금방 사라지기 때문에 많은 객체가 이 곳에서 사라진다. Old 영역 접근 불가능 상태가 되지 않고 Young 영역에서 살아남은 객체들이 복사된다. Young 영역 보다 크기가 크게 할당하고 큰 만큼 GC는 적게 발생한다. 이 영역에서 객체가 사라질때 Major GC라고 한다. Permanet 영역 Method Area라고도 한다. JVM이 클래스들과 메소드들을 설명하기 위해 필요한 메타데이터들을 포함하고 있다. 새로운 객체는 Eden space에 할당 된다. Eden space가 채워지면 minor garbage collection이 시작 된다. 참조되는 오브젝트들은 첫 번째 S0로 이동되어지고, 비 참조 객체는 Eden space가 clear 될 때 반환된다. 다음 minor garbage collection이 시작될때 Eden space에서 비 참조 객체는 삭제되고 참조객체는 참조 객체는 두번째 S1로 이동한다.또한 S0의 minor minor garbage collection를 통해 S1공간으로 이동하게 되며 age가 증가 된다.모든 객체들이 S1으로 이동하게 되면 S0와 Eden space는 Clear 된다. 다음 minor garbage collection에도 S0로 같은 작업이 반복된다. 그리고 Eden Space와 S1 공간은 Clear 된다. minor garbage collection 후 일정한 age를 넘게 되면 young generation에서 old로 승격 된다. minor garbage collection가 계속 발생하면 객체는 게속 old로 승격된다. 결국 major garbage collection가 일어나며 old가 Clear 되고 정리된다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Garbage Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB-join]]></title>
    <url>%2F2019%2F03%2F10%2FDB-join%2F</url>
    <content type="text"><![CDATA[JOIN조인이란?두개이상의 테이블이나 데이터베잇스를 연결하여 데이터를 검색하는 방법 이다. 보통 보통 Primary key혹은 Foreign key로 두 테이블을 연결한다. INNER JOIN결합된 테이블에 조건의 내용이 공통으로 들어가 있는 값을 결과 집합으로 만들어준다. 1234SELECT 열 목록FROM 첫번째 테이블 [AS 별칭] INNER JOIN 두번째 테이블 [AS별칭]ON(join_condition) OUTER JOININNER JOIN 문을 포함하고 한쪽에만 내용이 있더라도 지정한 기준 테이블에 있는 모든 데이터를 가져오는 조인 12345SELECT 열목록FROM 첫번째 테이블&lt;LEFT | RIGHT | FULL&gt; OUTER JOIN 두번째 테이블ON(join_condition)[WHERE 검색조건] LEFT OUTER JOIN왼쪽 테이블이 기준이 되어서 그 테이블에 있는 데이터를 모두 가져온다. 기준으로 지정되지 않은 오른쪽 테이블에서 가져올 수 없는 열은 NULL로 표현된다. RIGHT OUTER JOIN오른쪽 테이블이 기준이 되어서 그 테이블에 있는 데이터를 모두 가져온다. 기준으로 지정되지 않은 왼쪽 테이블에서 가져올 수 없는 열은 NULL로 표현된다. FULL OUTER JOIN왼쪽과 오른쪽에 관계없이 조건이 일치하지 않아도 양쪽의 모든 내용을 포함해서 나타낸다. CROSS JOIN결과값이 한쪽 테이블의 모든행들과 다른쪽 테이블의 모든 행을 조인시킨다.결과 집합은 두 테이블의 개수를 곱한 값만큼 생성되며, 조인되는 테이블에 공통되는 행이 없어도 되며 조건절인 ON 키워드가 사용되지 않는다.123SELECT 열목록FROM 첫번째 테이블 CROSS JOIN 두번째 테이블 SELF JOIN하나의 테이블에 같은 데이터가 존재하는데 그 의미가 다르게 존재하는 경우. 즉, 같은 데이터이지만 다른 열에 있는 경우에는 두 테이블을 서로 SELF JOIN 문으로 확인가능]]></content>
      <categories>
        <category>jobinterview</category>
      </categories>
      <tags>
        <tag>join</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB-index]]></title>
    <url>%2F2019%2F03%2F09%2FDB-index%2F</url>
    <content type="text"><![CDATA[indexindex란RDBMS에서 검색 속도를 높이는 기술중 하나이다. 대게 B-Tree, B+ Tree 구조를 갖는다. index는 해당 TABLE의 컬럼을 색인화 한다. index는 논리적/물리적으로 테이블과 독립적임 TABLE 에는 데이터의 레코드가 순서 없이 저장된다. 이때 데이터를 찾을 경우 데이터 페이지의 청므 레코드부터 끝 레코드까지 다 읽어 검색 조건과 비교하게 된다.이러한 방식을 full scan이라고 하는데 full scan이 아닌 색인화 되어 있는 index파일을 검색하여 검색속도를 빠르게 한다. index의 장단점 키 값을 기초로 하여 테이블에서 검색과 정렬 속도가 향상된다. 테이블의 기본 키는 자동으로 인덱스 된다. 인덱스를 만들면 .mdb 파일 크기가 늘어난다. 데이터를 업데이트 하거나 레코드를 추가 또는 삭제할 때 성능이 떨어진다. index 생성시 고려할 점 WHERE 절에서 사용되는 컬럼을 인덱스로 만든다. like ‘%~~~’는 조심(처음 %가 붙으면 table scan이 된다.) 데이터의 중복도가 높은 열은 인덱스로 만들지 않는다.(값이 true/false 이거나 성별 같은 경우) join, order by 에 자주 사용되는 열에는 인덱스를 생성해주는 것이 좋다. 외래키가 사용되는 열에는 인덱스를 생성해주는 것이 좋다. insert, delete, update 등 데이터의 변경이 많은 컬럼에는 인덱스를 걸지 않는 편이 좋음]]></content>
      <categories>
        <category>jobinterview</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Call by Value/Call by Reference]]></title>
    <url>%2F2019%2F03%2F08%2Fcallby%2F</url>
    <content type="text"><![CDATA[Call by Value/Call by Referencejava에서 인수로 매개 변수를 전달하는 방식이 크게 두가지다. 기본 데이터형은 모두 Call by Value로 처리되고 클래스의 객체는 Call by Reference로 처리 된다. Call by Value123456789101112131415Class CallByValue&#123; public static void swap(int x, int y) &#123; int temp = x; x = y; y = temp; &#125; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println("swap() 호출 전 : a = " + a + ", b = " + b); swap(a, b); System.out.println("swap() 호출 후 : a = " + a + ", b = " + b); &#125;&#125; 12swap() 호출 전 : a = 10, b = 20swap() 호출 후 : a = 10, b = 20 인수로 기본 데이터형을 사용하면 모두 Call by Value가 된다. 값을 복사하여 처리하기 때문에 메소드 밖의 변수에는 영향을 미치지 않게 되어 값이 변경되지 않는다. Call by Reference1234567891011121314151617181920Class CallByReference&#123; int value; CallByReference(int value) &#123; this.value = value; &#125; public static void swap(CallByReference x, CallByReference y) &#123;\ int temp = x.value; x.value = y.value; y.value = temp; &#125; public static void main(String[] args) &#123; CallByReference a = new CallByReference(10); CallByReference b = new CallByReference(20); System.out.println("swap() 호출 전 : a = " + a.value + ", b = " + b.value); swap(a, b); System.out.println("swap() 호출 전 : a = " + a.value + ", b = " + b.value); &#125;&#125; 12swap() 호출 전 : a = 10, b = 20swap() 호출 후 : a = 20, b = 10 CallByReference 클래스의 객체를 생성하여 값을 전달하게 되면 객체가 저장한 값이 주소값이기 때문에 swap메서드에서 변경시킨 결과가 main메서드로 돌려지게 된다. 이렇게 다른 메소드에서 현재의 메소드 내의 변수 값을 바꾸는 현상을 사이드 이펙트(side effect) 라고 한다. 사이드 이펙트 는 메소드 간의 값 전달을 쉽게 하기 때문에 편리하지만, 실수로 프로그래머가 모르는 사이에 값이 바뀌면 심각한 문제를 일으킬 수 있기 때문에 위험하다고 알려져 있다. 그래서 Java는 모든 기본 데이터형은 Call by Value로 값을 주고받아 ‘사이드 이펙트’가 일어나지 않도록 했고, Call by Reference가 필요한 경우는 명시적으로 클래스 객체를 주고받도록 정해둔 것이다.]]></content>
      <categories>
        <category>jobinterview</category>
      </categories>
      <tags>
        <tag>Call by Value</tag>
        <tag>Call by Reference</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http/https 차이점]]></title>
    <url>%2F2019%2F03%2F07%2Fhttp_https%2F</url>
    <content type="text"><![CDATA[http/httpshttp http는 HyperText Tranfer Protocol의 약자로 www상에서 정보를 주고 받는 프로토콜이다. http는 텍스트 교환으로 네트워크상에서 정보를 누군가가 마음대로 열람, 수정이 가능하다. 위에 보이는 warning페이지가 http로 보내는 정보를 무단으로 열람하여 redirect 하는 경우 https 뒤에 붙는 S는 Secure Socket의 약어로 보안성을 강화한 프로토콜 일반 텍스트를 이용하는 대신에, SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화 한다. https의 원리의 핵심은 공개키 암호화 방식 이다. 공개키 암호화 방식 공개키 방식에서는 두 개의 키를 갖는다. 누구에게나 공개가 가능한 공개키, 자신만이 갖고 있는 개인키 A키로 암호화 하면 B키로 복호화 가능 B키로 암호화 하면 A키로 복호화 가능 클라이언트는 공개키를 얻은 사용자가 암호화 하여 정보를 보내고, 서버는 개인키로 해독하여 요청에 대해 처리한다. 서버가 정보를 제공할 때 개인키로 암호화하면 공개키로 복호화 할 수 있다는 점을 통해 서버에서 개인키로 암호화 했다는 것을 보장할 수 있다. 이렇게 믿을 수 있는경우 브라우저에서는 주소 창의 색을 다르게 하여 안전하다고 알려 준다.]]></content>
      <categories>
        <category>jobinterview</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
        <tag>public-key cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/UDP 차이점]]></title>
    <url>%2F2019%2F03%2F06%2FTCP_UDP%2F</url>
    <content type="text"><![CDATA[TCP/UDPTCP 신뢰성있는 데이터 전송을 지원하는 연결지향형 프로토콜 Sequence Number, Ack Number를 통한 신뢰성 보장 연결의 설정(3-way handshaking)과 해제(4-way handshaking) 흐름제어와 혼잡제어를 지원하며 데이터의 순서를 보장 UDP 일방적으로 데이터를 전달하는 비연결형 프로토콜 데이터 전송에 대한 보장을 하지 않음 (비신뢰성) 헤더에 Checksum 필드를 통한 최소한의 오류검출 속도가 빠름 3-way handshaking연결을 하여 데이터를 전송하기 위해 TCP에서 3-way handshaking 과정을 거친다. 접속 요청 프로세스가 연결요청 메시지 전송(SYN) 접속 요청을 받은 프로세스가 수락 (SYN + ACK) 마지막으로 접속 요청 프로세스가 수락 확인을 보내 연결을 맺음(ACK) SYN(Synchronization) : 연결요청, 세션을 설정하는데 사용되며 초기에 시퀀스 번호를 보냄 ACK(Acknowledgement) : 보낸 시퀀스 번호에 TCP 계층에서의 길이 또는 양을 더한 것과 같은 값을 ACK에 포함하여 전송 4-way handshaking 4-way handshaking는 세션을 종료하기 위해 수해되는 절차이다. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다. 서버는 일단 확인메시지를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 TIME_WAT 상태 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송 클라이언트는 확인했다는 메시지를 보냄 FIN(Finish) : 세션을 종료시키는데 사용되며 더 이상 보낸 데이터가 없음을 표시]]></content>
      <categories>
        <category>jobinterview</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>3-way handshaking</tag>
        <tag>4-way handshaking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm]백준-톱니바퀴]]></title>
    <url>%2F2019%2F02%2F15%2FAlgorithm-gear%2F</url>
    <content type="text"><![CDATA[톱니바퀴 출처 문제 설명총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이 일렬로 놓여져 있다. 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, 그 오른쪽은 3번, 가장 오른쪽 톱니바퀴는 4번이다. 이때, 톱니바퀴를 총 K번 회전시키려고 한다. 톱니바퀴의 회전은 한 칸을 기준으로 한다. 회전은 시계 방향과 반시계 방향이 있고, 아래 그림과 같이 회전한다. 톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다. 톱니바퀴가 회전할 때, 서로 맞닿은 극에 따라서 옆에 있는 톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다. 톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면, B는 A가 회전한 방향과 반대방향으로 회전하게 된다. 예를 들어, 아래와 같은 경우를 살펴보자. 두 톱니바퀴의 맞닿은 부분은 초록색 점선으로 묶여있는 부분이다. 여기서, 3번 톱니바퀴를 반시계 방향으로 회전했다면, 4번 톱니바퀴는 시계 방향으로 회전하게 된다. 2번 톱니바퀴는 맞닿은 부분이 S극으로 서로 같기 때문에, 회전하지 않게 되고, 1번 톱니바퀴는 2번이 회전하지 않았기 때문에, 회전하지 않게 된다. 따라서, 아래 그림과 같은 모양을 만들게 된다. 위와 같은 상태에서 1번 톱니바퀴를 시계 방향으로 회전시키면, 2번 톱니바퀴가 반시계 방향으로 회전하게 되고, 2번이 회전하기 때문에, 3번도 동시에 시계 방향으로 회전하게 된다. 4번은 3번이 회전하지만, 맞닿은 극이 같기 때문에 회전하지 않는다. 따라서, 아래와 같은 상태가 된다. 톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때, 최종 톱니바퀴의 상태를 구하는 프로그램을 작성하시오. 입력첫째 줄에 1번 톱니바퀴의 상태, 둘째 줄에 2번 톱니바퀴의 상태, 셋째 줄에 3번 톱니바퀴의 상태, 넷째 줄에 4번 톱니바퀴의 상태가 주어진다. 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다. N극은 0, S극은 1로 나타나있다. 다섯째 줄에는 회전 횟수 K(1 ≤ K ≤ 100)가 주어진다. 다음 K개 줄에는 회전시킨 방법이 순서대로 주어진다. 각 방법은 두 개의 정수로 이루어져 있고, 첫 번째 정수는 회전시킨 톱니바퀴의 번호, 두 번째 정수는 방향이다. 방향이 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향이다. 출력총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합을 출력한다. 점수란 다음과 같이 계산한다. 1번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 1점 2번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 2점 3번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 4점 4번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 8점 입출력 예제 소스 코드자바123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package ag;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;public class Main &#123; // Gear 클래스로 만들고 싶었지만 백준 체점을 위해 이름을 Main 클래스로 변경 int[] state = null; public int top =0; // 톱니바퀴 처음 맨위의 인덱스 public int right = 2; // 톱니바퀴 3시방향 처음 인덱스 public int left = 6; // 톱니바퀴 9시방향 처음 인덱스 public int direct = 0; // 톱니바퀴가 어떤 방향으로 돌지 Main rightGear=null; // 톱니바퀴의 오른쪽 톱니바퀴 Main leftGear=null; // 톱니바퀴의 왼쪽 톱니바퀴 public Main(int[] state)&#123; //톱니바퀴 클래스의 생성자로 톱니바퀴의 톱니에 적힌 극을 배열로 저장 this.state=state; &#125; public void setRightGear(Main rightGear)&#123; this.rightGear =rightGear; &#125; // 오른쪽 톱니바퀴를 등록 public void setLeftGear(Main leftGear)&#123; this.leftGear =leftGear; &#125; // 왼쪽 톱니바퀴를 등록 public void startTurn(int num)&#123; // 맨처음 톱니바퀴를 돌릴때 실행시킬 메서드 this.direct=num; if(rightGear!=null &amp;&amp; leftGear!=null)&#123; // 좌우 톱니바퀴가 모두 존재할 경우 양쪽으로 톱니바퀴 돌리는 메서드 실행 rightTurn(direct*-1); //좌우 톱니바퀴는 자신과 반대로 돌기때문에 -1을 곱해 반대 값을 넘겨줌 leftTurn(direct*-1); &#125; else if(rightGear==null)&#123; // 왼쪽 톱니바퀴만 존재할 경우 leftTurn(direct*-1); &#125; else if(leftGear==null)&#123; // 오른쪽 톱니바퀴만 존재할 경우 rightTurn(direct*-1); &#125; turn(); //좌우 모든 톱니바퀴를 돌리고 나서 자신의 톱니바퀴를 돌림 &#125; public void turn()&#123; // 톱니바퀴를 돌리는 메서드 배열을 직접 바꾸지않고 top, left, right 값만 바꿔줌 if(direct ==-1)&#123; if(top==7)top =0; else top++; if(right==7)right=0; else right++; if(left==7)left=0; else left++; &#125; else if(direct==1)&#123; if(top==0)top =7; else top--; if(right==0)right=7; else right--; if(left==0)left=7; else left--; &#125; &#125; public void rightTurn(int num)&#123; rightGear.direct=num; // 오른쪽 톱니바퀴의 방향에 자신과 반대의 값을 넣어줌 if(rightGear.rightGear==null&amp;&amp;this.state[this.right]!=rightGear.state[rightGear.left])&#123; //오른쪽 톱니바퀴의 오른쪽 톱니바퀴가 존재하지않고 자신의 오른쪽 값과 오른쪽 톱니바퀴의 왼쪽 값이 다를경우 rightGear.turn(); //오른쪽 톱니바퀴만 돌림 return; &#125; else if(this.state[this.right]!=rightGear.state[rightGear.left])&#123; //오른쪽 톱니바퀴의 오른쪽 톱니바퀴가 존재하고 자신의 오른쪽 값과 오른쪽 톱니바퀴의 왼쪽 값이 다를경우 rightGear.rightTurn(rightGear.direct*-1); //오른쪽 톱니바퀴의 rightTurn 메서드를 실행시켜 오른쪽 톱니바퀴의 오른쪽 톱니바퀴도 값비교후 돌림 rightGear.turn(); return; &#125; else&#123; // 자신의 오른쪽 값과 오른쪽 톱니바퀴의 왼쪽값이 다를 경우는 아무 작업 하지 않고 리턴 return; &#125; &#125; public void leftTurn(int num)&#123; leftGear.direct=num; if(leftGear.leftGear==null &amp;&amp; this.state[this.left]!=leftGear.state[leftGear.right])&#123; leftGear.turn(); return; &#125; else if(this.state[this.left]!=leftGear.state[leftGear.right])&#123; leftGear.leftTurn(leftGear.direct*-1); leftGear.turn(); return; &#125; else&#123; return; &#125; &#125; public int score()&#123; //맨위의 값이 1일 경우는 점수있음 if(this.state[this.top]==1)return 1; else return 0; &#125; static BufferedReader br =null; public static void main(String[] args) throws IOException &#123; int answerScore =0; //정답을 만들기 위한 변수 List&lt;int[]&gt; arrayList = new ArrayList&lt;&gt;(); br = new BufferedReader(new InputStreamReader(System.in)); for(int i=0; i&lt;4;i++)&#123; int[] gearStateArray =new int[8]; String arrayString = br.readLine(); for(int j=0;j&lt;arrayString.length();j++)&#123; gearStateArray[j]=arrayString.charAt(j) -'0'; &#125; arrayList.add(gearStateArray); &#125; Main gear1 = new Main(arrayList.get(0)); // 톱니바퀴 1 생성 Main gear2 = new Main(arrayList.get(1)); // 톱니바퀴 2 생성 Main gear3 = new Main(arrayList.get(2)); // 톱니바퀴 3 생성 Main gear4 = new Main(arrayList.get(3)); // 톱니바퀴 4 생성 gear1.setRightGear(gear2); //톱니바퀴의 양옆 톱니바퀴들 등록 gear2.setLeftGear(gear1); //톱니바퀴의 양옆 톱니바퀴들 등록 gear2.setRightGear(gear3); //톱니바퀴의 양옆 톱니바퀴들 등록 gear3.setLeftGear(gear2); //톱니바퀴의 양옆 톱니바퀴들 등록 gear3.setRightGear(gear4); //톱니바퀴의 양옆 톱니바퀴들 등록 gear4.setLeftGear(gear3); //톱니바퀴의 양옆 톱니바퀴들 등록 int count = Integer.parseInt(br.readLine()); int gear,direct; for(int i=0; i&lt;count;i++)&#123; StringTokenizer st = new StringTokenizer(br.readLine(), " "); gear =Integer.parseInt(st.nextToken()); direct = Integer.parseInt(st.nextToken()); if(gear==1 &amp;&amp; direct==1) gear1.startTurn(1); else if(gear==1 &amp;&amp; direct==-1) gear1.startTurn(-1); else if(gear==2 &amp;&amp; direct==1) gear2.startTurn(1); else if(gear==2 &amp;&amp; direct==-1) gear2.startTurn(-1); else if(gear==3 &amp;&amp; direct==1) gear3.startTurn(1); else if(gear==3 &amp;&amp; direct==-1) gear3.startTurn(-1); else if(gear==4 &amp;&amp; direct==1) gear4.startTurn(1); else if(gear==4 &amp;&amp; direct==-1) gear4.startTurn(-1); &#125; answerScore+=gear1.score() + (gear2.score()*2) + (gear3.score()*4) + (gear4.score()*8); //각 톱니바퀴에 점수에 맞게 계산 System.out.println(answerScore); &#125;&#125; 소스코드 설명저는 우선 링크드 리스트를 이용하여 톱니바퀴가 바뀔때마다 리스트를 변경하려고 하였습니다. 그러나 그냥 좌, 우, 위의 인덱스 정보만 저장 해놓고 변경하는식으로 사용하면 될 거같아 배열을 사용하기로 하였습니다. 톱니바퀴 객체를 만들고 그안에 인덱스와 배열 정보들을 기초변수로 각 기어의 양 옆 기어들을 저장시키기위한 톱니바퀴 클래스 참조변수 두개를 변수로 두고 set 메서드로 연결 시키도록 하였습니다. turn 메서드는 톱니바퀴가 돌았을때의 효과를 주기 위한 인덱스 변경 메서드입니다. startTurn 메서드는 맨 처음 입력값에서 톱니바퀴를 돌릴 경우 양 옆의 톱니바퀴가 존재할 경우 양 옆으로 회전을 전이시키기 위해 따로 작성한 메서드 입니다. leftTurn, rightTurn 메서드는 각각 옆의 톱니바퀴가 돌아야 한다면 돌리고, 옆의 톱니바퀴에서도 메서드를 실행시켜 옆옆의 톱니바퀴들도 게속 확인하며 돌리는 메서드입니다.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>백준</tag>
        <tag>톱니바퀴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm]프로그래머스-영어 끝말잇기]]></title>
    <url>%2F2019%2F02%2F03%2FAlgorithm-wordChain%2F</url>
    <content type="text"><![CDATA[영어 끝말잇기문제 설명1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다. 다음은 3명이 끝말잇기를 하는 상황을 나타냅니다. tank → kick → know → wheel → land → dream → mother → robot → tank 위 끝말잇기는 다음과 같이 진행됩니다. 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다. 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다. 3번 사람이 자신의 첫 번째 차례에 know를 말합니다. 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다. (계속 진행) 끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다. 제한 사항 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다. words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다. 단어의 길이는 2 이상 50 이하입니다. 모든 단어는 알파벳 소문자로만 이루어져 있습니다. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다. 정답은 [ 번호, 차례 ] 형태로 return 해주세요. 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요. 입출력 예 n words result 3 [tank, kick, know, wheel, land, dream, mother, robot, tank] [3,3] 5 [hello, observe, effect, take, either, recognize, encourage, ensure, establish, hang, gather, refer, reference, estimate, executive] [0,0] 24 [hello, one, even, never, now, world, draw] [1,3] 소스 코드자바123456789101112131415161718192021import java.util.HashSet;class Solution &#123; public int[] solution(int n, String[] words) &#123; int[] answer = &#123;0,0&#125;; char wordStart; // 두번째 단어부터 첫번째 문자 저장을 위한 변수 선언 char wordEnd = words[0].charAt(words[0].length()-1); //처음 단어의 마지막 문자를 저장 HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); hashSet.add(words[0]); // 첫단어를 해쉬셋에 저장 for(int i=1; i&lt;words.length;i++)&#123; hashSet.add(words[i]); wordStart = words[i].charAt(0); if(wordEnd!=wordStart || hashSet.size() != i+1)&#123; answer[0] = (i%n)+1; answer[1] = (i/n)+1; break; &#125; wordEnd= words[i].charAt(words[i].length()-1); //다음단어의 처음 알파벳 비교를 위해 이번 단어의 마지막 알파벳 저장 &#125; return answer; &#125;&#125; 소스코드 설명 단어의 끝 알파벳과 그 다음 첫 알파벳이 다른 단어를 찾아라. 중복된 단어를 찾아라. 문자열이 저장된 배열에서 단어 한개씩 새로운 자료구조에 담으면서 문자열의 마지막 문자와 다음 문자의 처음 문자를 비교하면서 1번을 해결하려 하였습니다. 담으면서 중복됬는지를 확인하기 위하여 자료구조는 HashSet을 이용하였습니다. HashSet에는 중복 문자가 한번밖에 저장되지 않는 점을 이용하여 size()메서드를 이용하여 담기는 문자열이 이미 사용된 문자열인지 판단하였습니다.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>프로그래머스</tag>
        <tag>끝말잇기</tag>
        <tag>영어 끝말잇기</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm]프로그래머스-카펫]]></title>
    <url>%2F2019%2F02%2F02%2FAlgorithm-carpet%2F</url>
    <content type="text"><![CDATA[카펫문제 설명Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 빨간색으로 칠해져 있고 모서리는 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. Leo는 집으로 돌아와서 아까 본 카펫의 빨간색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다. Leo가 본 카펫에서 갈색 격자의 수 brown, 빨간색 격자의 수 red가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다. 빨간색 격자의 수 red는 1 이상 2,000,000 이하인 자연수입니다. 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다. 입출력 예 brown red return 10 2 [4,3] 8 1 [3,3] 24 24 [8,6] 출처 소스 코드자바123456789101112131415161718192021class Solution &#123; public int[] solution(int brown, int red) &#123; int[] answer = new int[2]; int garo; int sero; for(int i=1; i&lt;= red;i++)&#123; if(red%i==0)&#123; garo = i &gt;= red/i? i :red/i; sero = i &gt;= red/i? red/i :i; System.out.println(garo); System.out.println(sero); if(brown == (sero*2)+((garo+2)*2))&#123; answer[0]=garo+2; answer[1]=sero+2; break; &#125; &#125; &#125; return answer; &#125;&#125; 소스코드 설명저는 카펫에 갈색 부분이 빨간 부분의 세로2 개, (가로+2)2 개만큼 있다는걸 발견 하였습니다. 빨간 부분의 개수를 이용해서 가로 세로가 되는 경우를 전부 구하며 그경우에 위에 식을 대입하여 갈색 부분의 갯수와 일치 하는지 확인하였습니다. 일치하는 경우가 빨간 부분의 가로 세로가 되고 전체 카펫의 가로와 세로의 길이는 빨간 부분의 가로와 세로에 각각 2개만큼 더한게 됩니다. 몫과 나머지를 이용하여 빨간 부분의 가로세로를 구하는 부분에서 더 큰값을 가로로 잡기위해 삼항연산자를 사용하였습니다.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>프로그래머스</tag>
        <tag>완전탐색</tag>
        <tag>카펫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm]기본적인 정렬 알고리즘]]></title>
    <url>%2F2019%2F02%2F01%2FAlgorithm-sort%2F</url>
    <content type="text"><![CDATA[선택정렬 주어진 리스트 중에 최소값을 찾는다. 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)). 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다. 시간 복잡도Best : O(n^2) Avg : O(n^2) Worst : O(n^2) 소스 코드1234567891011int[] a = new int[]&#123;2,4,1,3,6,7,5,8,10,9&#125;;for(int i=0;i&lt;a.length-1;i++)&#123; int min = i; for(int j=i+1;j&lt;a.length;j++)&#123; if(a[j]&lt;a[min])&#123; min=j; &#125; &#125; swap(a,min,i); &#125; System.out.println(Arrays.toString(a)); 버블정렬버블 정렬(Bubble Sort)은 인접한 두개의 원소를 비교하여 자리를 교환하는 방식으로 정렬 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막자리로 이동하는 모습이 물속에서 물 위로 올라오는 물방울 모양과 같다고 해서 버블 정렬이라고 한다 시간 복잡도Best : O(n^2) Avg : O(n^2) Worst : O(n^2) 소스 코드123456789int[] b = new int[]&#123;2,4,1,3,6,7,5,8,10,9&#125;;ffor(int i=0; i&lt;b.length-1;i++)&#123; for(int j=0;j&lt;b.length-1;j++)&#123; if(b[j]&gt;b[j+1])&#123; swap(b,j,j+1); &#125; &#125; &#125; System.out.println(Arrays.toString(b)); 삽입정렬삽입 정렬(insertion sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다. 시간 복잡도Best : O(n) Avg : O(n^2) Worst : O(n^2) 소스 코드1234567891011int[] c = new int[]&#123;2,4,1,3,6,7,5,8,10,9&#125;;for(int i=1; i&lt;c.length;i++)&#123; int j=i; int temp=c[i]; while(j&gt;0&amp;&amp;c[j-1]&gt;temp)&#123; c[j]=c[j-1]; j--; &#125; c[j]=temp; &#125;System.out.println(Arrays.toString(c)); 퀵정렬분할 작업을 순환적으로 반복하면서 피봇의 왼쪽 왼쪽 부분 집합과 오른쪽 부분집합을 정렬 하는 방법 전체원소 가운데 하나의 원소를 중심(Pivot)으로 2개의 부분 집합으로 분할 한다. 기준값(Pivot) 보다 작은 원소는 왼쪽 부분집합으로, 기준값(Pivot) 보다 큰 원소들은 오른쪽 부분 집합으로 정렬한다. 분할된 부분집합의 크기가 0이나 1이 될 때 까지 순환 호출을 이용하여 다시 분할 한다. 시간 복잡도Best : O(nlogn) Avg : O(nlogn) Worst : O(n^2) 소스 코드1234567891011121314151617181920212223242526272829public int pivot(int[] array, int start, int end)&#123; int middle = array[(start+end)/2]; while(start&lt;end) &#123; while (array[start] &lt; middle &amp;&amp; start &lt; end) start++; while (array[end] &gt; middle &amp;&amp; start &lt; end) end--; if (start &lt; end) &#123; int temp = array[start]; array[start] = array[end]; array[end] = temp; &#125; &#125; return start;&#125; public void quicksort(int[] array,int start,int end )&#123; if(start&lt;end)&#123; int middle = pivot(array,start,end); quicksort(array, start,middle-1); quicksort(array,middle+1,end); &#125;&#125;int[] d = new int[]&#123;2,4,1,3,6,7,5,8,10,9&#125;;@Testpublic void sort()&#123; quicksort(d,0,d.length-1); System.out.println(Arrays.toString(d));&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>sort</tag>
        <tag>sorting</tag>
        <tag>버블정렬</tag>
        <tag>선택정렬</tag>
        <tag>삽입정렬</tag>
        <tag>퀵정렬</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST API 만들기-4]]></title>
    <url>%2F2019%2F01%2F27%2FREST-API-4%2F</url>
    <content type="text"><![CDATA[스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. 입력값 제한하기현재 API는 입력값으로 id 또는 입력 받은 데이터를 가지고 계산해야하는 값까지도 입력으로 줄 수가 있습니다. 이번 포스팅에서는 입력으로 받으면 안되는 값들을 EventDTO를 적용하여 제한하는 방법에 대해서 알아보겠습니다. EventDTOEvent 클래스에 어노테이션을 추가해서 DTO로 분리하는것과 같은 기능을 할 수는 있지만, 그런경우에 도메인 클래스에 너무 많은 어노테이션이 추가 됩니다. 12345678910111213@Builder @NoArgsConstructor @AllArgsConstructor @Datapublic class EventDto &#123; private String name; private String description; private LocalDateTime beginEnrollmentDateTime; private LocalDateTime closeEnrollmentDateTime; private LocalDateTime beginEventDateTime; private LocalDateTime endEventDateTime; private String location; // (optional) 이게 없으면 온라인 모임 private int basePrice; // (optional) private int maxPrice; // (optional) private int limitOfEnrollment;&#125; 받기로 한 값들만 가지고 EventDTO 클래스를 만듭니다. ModelMapper입력 타입을 DTO로 바꿧으니 DTO를 다시 Event 객체로 변경해주어야 Event 타입으로 바꿔 주어야 EventRepository 를 쓸수 있습니다. EventDTO 객체를 Event객체로 바꿔주려면 직접 옮기는 방법도 있지만 ModelMapper 를 사용해 쉽게 바꿔줄수 있습니다. pom.xml 123456&lt;!-- https://mvnrepository.com/artifact/org.modelmapper/modelmapper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.modelmapper&lt;/groupId&gt; &lt;artifactId&gt;modelmapper&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; 빈등록1234@Bean public ModelMapper modelMapper()&#123; return new ModelMapper(); &#125; EventController12345678910 private final ModelMapper modelMapper; public EventController(EventRepository eventRepository, ModelMapper modelMapper)&#123; this.eventRepository = eventRepository; this.modelMapper = modelMapper; &#125;``` 생성자를 통해 ModelMapper 주입을 받습니다.```javaEvent event = modelMapper.map(eventDto,Event.class); 이렇게 ModelMapper를 통해 Event 객체로 변환할 수 있습니다. EventControllerTests테스트에서 더이상 테스트에서 만든 Event객체를 쓰지 않기 때문에 Mockito를 사용해서 Stubbing 하는 기능이 적용되지 않습니다. 그래서 이제 @WebMvcTest 어노테이션을 지우고 @SpringBootTest 와 SpringBootTest에서 MockMvc를 쓰기위해@AutoConfigureMock0Mvc 를 추가하여줍니다. 123456789101112mockMvc.perform(post("/api/events") .contentType(MediaType.APPLICATION_JSON_UTF8) .accept(MediaTypes.HAL_JSON) .content(objectMapper.writeValueAsString(event))) .andDo(print()) .andExpect(status().isCreated()) .andExpect(jsonPath("id").exists()) .andExpect(header().exists(HttpHeaders.LOCATION)) .andExpect(header().string(HttpHeaders.CONTENT_TYPE,MediaTypes.HAL_JSON_UTF8_VALUE)) .andExpect(jsonPath("id").value(Machers.not(10))) .andExpect(jsonPath("free").value(Machers.not(true))) .andExpect(jsonPath("eventStatus").value(Machers.not(true))); id, free, eventStatus 같은 입력으로 받아서 안되는 값들이 잘 제한됬는지 이렇게 코드를 추가하여 확인할 수 있습니다.]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST API 만들기-3]]></title>
    <url>%2F2019%2F01%2F26%2FREST-API-3%2F</url>
    <content type="text"><![CDATA[스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. event 객체를 실제 DB에 저장 시키기Event 클래스 수정12345678910@Builder @AllArgsConstructor @NoArgsConstructor@Getter @Setter @EqualsAndHashCode(of="id")@Entitypublic class Event &#123; @Id @GeneratedValue private Integer id; ... @Enumerated(EnumType.STRING) //string을 더 권장 private EventStatus eventStatus = EventStatus.DRAFT; Event 클래스 각 위치에 @Entity @ID @GeneratedValue @Enumerated 어노테이션을 추가해준다. @Entity 이 어노테이션은 해당 클래스가 엔티티임을 알리기 위해 사용합니다. 애플리케이션이 실행이 될 때 엔티티 자동검색을 통하여 이 어노테이션이 선언 된 클래스들은 엔티티 빈으로 등록합니다. @Id 엔티티빈의 기본키를 의미합니다. 이 어노테이션은 하나의 엔티티에는 반드시 하나가 존재해야 합니다. @GeneratedValue 데이터베이스에 의해 자동으로 생성된 값이라는 의미입니다. 즉, 프로그램 상에서 조작된 데이터가 아닌, 실제 데이터베이스에 데이터가 영속(저장)될 때 생성되는 값입니다.@Enumerated(EnumType.STRING) EnumType.ORDINAL을 이용하면 Enum 순서 값을 DB에 저장합니다 EnumType.STRING을 이용하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장됩니다.EventRepository 인터페이스 작성123public interface EventRepository extends JpaRepository&lt;Event,Integer&gt; &#123;&#125; EventController 클래스 수정123456789101112@RequestMapping(value ="/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE )public class EventController&#123; public EventController(EventRepository eventRepository)&#123; this.eventRepository = eventRepository; &#125; @PostMapping public ResponseEntity createEvent(@RequestMapping Event event)&#123; Event newEvent = this.eventRepository.save(event); //JPA를 이용한 저장 URI createdUri = linkTo(EventController.class).slash(newEvent.getId()).toUri(); //DB에 저장되며 생성된 ID값을 이용 return ResponseEntity.created(createdUri).body(event); &#125;&#125; EventControllerTests 클래스 수정12345678910111213141516171819202122232425@RunWith(SpringRunner.class)@WebMvcTest //web과 관련된 빈들이 등록 됨public class EventControllerTests &#123; @MockBean EventRepository eventRepository; @Test public void createEvent() throws Exception&#123; ... event.setId(10); Mockito.when(eventRepository.save(event)).thenReturn(event); mockMvc.perform(post("/api/events") .contentType(MediaType.APPLICATION_JSON_UTF8) .accept(MediaTypes.HAL_JSON) .content(objectMapper.writeValueAsString(event))) .andDo(print()) .andExpect(status().isCreated()) .andExpect(jsonPath("id").exists()) .andExpect(header().exists(HttpHeaders.LOCATION)) .andExpect(header().string(HttpHeaders.CONTENT_TYPE,MediaTypes.HAL_JSON_UTF8_VALUE)); ... &#125; MockBean MockBean으로 만든 eventRepository는 Mock객체이기때문에 save를 하여도 리턴 값이 null이다. 그렇기 때문에 Mockito를 사용해서 Stubbing 해주었다.]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST API 만들기-2]]></title>
    <url>%2F2019%2F01%2F25%2FREST-API-2%2F</url>
    <content type="text"><![CDATA[스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. Event 생성 APITDD를 위한 테스트 작성테스트 할것입력값들을 전달하면 JSON 응답으로 201이 나오는지 확인. Location 헤더에 생성된 이벤트를 조회할 수 있는 URI 담겨 있는지 확인. id는 DB에 들어갈 때 자동생성된 값으로 나오는지 확인 EventControllerTest 클래스 생성12345678910111213141516171819202122232425262728293031323334@RunWith(SpringRunner.class)@WebMvcTest //web과 관련된 빈들이 등록 됨public class EventControllerTests &#123; @Autowired MockMvc mockMvc; // 가짜 요청을 만들어 DispatcherServlet 에게 보내고 응답을 확인(웹서버를 띄우진 않음) @Autowired ObjectMapper objectMapper; //자동으로 빈으로 등록해줌 @Test public void createEvent()&#123; Event event = Event.builder() .name("Spring") .description("REST API Development with Spring") .beginEnrollmentDateTime(LocalDateTime.of(2018,11,23,14,22)) .closeEnrollmentDateTime(LocalDateTime.of(2018,11,24,14,22)) .beginEventDateTime(LocalDateTime.of(2018,11,25,14,22)) .endEventDateTime(LocalDateTime.of(2018,11,26,14,22)) .basePrice(100) .maxPrice(200) .limitOfEnrollment(100) .location("강남역 D2 스타텁 팩토리") .build(); mockMvc.perform(post("/api/events") .contentType((MediaType).APPLICATION_JSON_UTF8) .accepot(MediaTypes.HAL_JSON) .content(objectMapper.writeValueAsString(event))) .andDo(print()) .andExpect(status().isCreated() .andExpect(jsonPath("id").exists()); &#125; &#125; @WebMvcTest MockMvc 빈을 자동 설정 웹 관련 빈만 등록.(슬라이스) MockMvc 스프링 MVC 테스트 핵심클래스 웹 서버를 띄우지 않고도 스프링 MVC(DispatcherServlet)가 요청을 처리하는 과정을 확인할 수 있기 때문에 컨트롤러 테스트용으로 자주 쓰임 ObjectMapper 스프링 부트에 mapping Jackson이 의존성주입이 되있을경우 자동 빈등록 objectMapper.writeValueAsString(event) 객체를 JSON으로 변환! EventController 클래스 작성12345678910@RequestMapping(value ="/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE )public class EventController&#123; @PostMapping public ResponseEntity createEvent(@RequestMapping Event event)&#123; URI createdUri = linkTo(EventController.class).slash("&#123;id&#125;").toUri(); event.setID(10); //우선 임의로 아이디값을 준다. return ResponseEntity.created(createdUri).body(event); &#125;&#125; 테스트를 진행하면 정상적으로 실행이 된다.]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST API 만들기-1]]></title>
    <url>%2F2019%2F01%2F24%2FREST-API-1%2F</url>
    <content type="text"><![CDATA[스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. 추가할 의존성 및 JDK 버전 Web JPA HATEOAS REST Docs H2 PostgreSQL Lombok JDK 11입력으로 받을 값들 name description beginEnrollmentDateTime closeEnrollmentDateTime beginEventDateTime endEventDateTime location (optional) 이게 없으면 온라인 모임 basePrice (optional) maxPrice (optional) limitOfEnrollment basePrice maxPrice 설명 0 100 선착순등록 0 0 무료 100 0 무제한 경매(높은 금액 낸 사람이 등록) 100 200 제한가 선착순 등록 결과로 줄 값들 name … eventStatus: DRAFT, PUBLISHED, ENROLLMENT_STARTED, … offline free _links profile (for the self-descriptive message) self publish시작하기Event 클래스 만들기.패키지를 하나 만들고 그안에 Event 클래스를 생성한다.이벤트 클래스는 나중에 DB의 테이블과 매칭될 Entity 클래스 이다.123456789101112public class Event &#123; private String name; private String description; private LocalDateTime beginEnrollmentDateTime; private LocalDateTime closeEnrollmentDateTime; private LocalDateTime beginEventDateTime; private LocalDateTime endEventDateTime; private String location; private int basePrice; private int maxPrice; private int limitOfEnrollment;&#125; EventStatus enum 클래스 생성123public enum EventStatus &#123; DRAFT, PUBLISHED, BEGEAN_ENROLLMENT;&#125; Event 클래스에 lombok 어노테이션 추가12@Builder @AllArgsConstructor @NoArgsConstructor@Getter @Setter @EqualsAndHashCode(of="id") Test 클래스를 만들어 junit 테스트12345678910111213141516171819202122232425@Testpublic void builder()&#123; Event event = Event.builder() .name("inflearn") .description("rst API") .build(); assertThat(event).isNotNull();&#125;@Testpublic void JavaBean()&#123; //Given String name = "Event"; String description = "Spring"; //When Event event = new Event(); event.setName("Event"); event.setDescription("Spring"); //Then assertThat(event.getName()).isEqualTo(name); assertThat(event.getDescription()).isEqualTo(description);&#125; Lombok 과 AssertJ의 추가적인 설명 LombokAssertJ]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring-library]AssertJ란?]]></title>
    <url>%2F2019%2F01%2F23%2FSpring-AssertJ%2F</url>
    <content type="text"><![CDATA[AsertJ란? java test를 위해 좀 더 풍부한 문법을 제공하고 메서드 체이닝을 통해 직관적인 테스트 흐름을 작성할 수 있도록 개발된 오픈소스 라이브러리이다. 최근 junit에 필수로 사용되고 있는 추세이다. 공식홈페이지 시작하기라이브러리 의존성 설정Maven1234567&lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;!-- use 2.9.1 for Java 7 projects --&gt; &lt;version&gt;3.11.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Gradle1testCompile("org.assertj:assertj-core:3.11.1") 또는 Java 7 프로젝트의 경우 버전 2.9.11testCompile("org.assertj:assertj-core:2.9.1") AssertJ 메소드 임포트1import static org.assertj.core.api.Assertions.*; 실제 사용1assertThat(objectUnderTest). // code completion -&gt; assertions specific to objectUnderTest 모든 테스트 코드는 assertThat() 메소드에서 시작한다. ###문자열 테스트12345678assertThat("Hello, world! Nice to meet you.") // 주어진 "Hello, world! Nice to meet you."라는 문자열은 .isNotEmpty() // 비어있지 않고 .contains("Nice") // "Nice"를 포함하고 .contains("world") // "world"도 포함하고 .doesNotContain("ZZZ") // "ZZZ"는 포함하지 않으며 .startsWith("Hell") // "Hell"로 시작하고 .endsWith("u.") // "u."로 끝나며 .isEqualTo("Hello, world! Nice to meet you."); // "Hello, world! Nice to meet you."과 일치합니다. 숫자 테스트1234567assertThat(3.14d) // 주어진 3.14라는 숫자는 .isPositive() // 양수이고 .isGreaterThan(3) // 3보다 크며 .isLessThan(4) // 4보다 작습니다 .isEqualTo(3, offset(1d)) // 오프셋 1 기준으로 3과 같고 .isEqualTo(3.1, offset(0.1d)) // 오프셋 0.1 기준으로 3.1과 같으며 .isEqualTo(3.14); // 오프셋 없이는 3.14와 같습니다]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>library</tag>
        <tag>Test</tag>
        <tag>AssertJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST API란]]></title>
    <url>%2F2019%2F01%2F23%2FREST-API%2F</url>
    <content type="text"><![CDATA[스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. API Application Programming Interface 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. REST REpresentational State Treansfer 인터넷 상의 시스템 간의 상호 운용성(Interoperability)을 제공하는 방법중 하나 시스템 제각각의 독립적인 진화를 보장하기 위한 방법 REST API : REST 아키텍처 스타일을 따르는 API 그런 REST API로 괜찮은가 그런 REST API로 괜찮은가 - 이응준님 강연을 보고 작성하였습니다. 오늘날 대부분의 “REST API”는 사실 REST를 따르지 않고 있다. REST의 제약조건 중에서 특히 Self-descriptive와 HATEOAS를 잘 만족하지 못한다. REST를 따르겠다면, Self-descriptive와 HATEOAS를 만족시켜야한다. Self-descriptive는 custom media type이나 profile link relation 등으로 만족시킬 수 있다. HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.Self descriptive message 메세지 스스로 메세지에 대한 설명이 가능해야 한다. 이렇지 않으면 API문서를 항상 만들어야 한다. API만 보고 의미를 알 수 없기 때문이다. Self descriptive message를 달성하기 위한 방법 미디어 타입을 IANA에 등록하고 그 미디어 타입을 리소스 리턴할 때 Content-Type으로 사용한다. ProFile 의미가 뭔지 정보가 담긴 문서 링크 헤더를 추가한다. HATEOAS 하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 하며 링크 정보를 동적으로 바꿀 수 있다. HATEOS는 애플리케이션 상태 전이의 late binding을 가능하게 하기 때문에 필요하다.어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이될 수 있는 상태가 결정된다. 링크는 동적으로 변경될 수 있다. 언제나 서버가 마음대로 바꿀 수 있음.HATEOAS를 달성하기 위한 방법 데이터 링크 제공 HTTP 헤더에 Location, Link를 활용하는 방법]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring-library]Lombok이란?]]></title>
    <url>%2F2019%2F01%2F23%2FSpring-Lombok%2F</url>
    <content type="text"><![CDATA[Lombok이란? Lombok은 자바에서 Model(DTO, VO, Domain Class) 클래스를 작성할 때, 멤버 변수에 대한 Getter/Setter Method, Equals(), hashCode(), ToString()과 멤버 변수에 값을 설정하는 생성자 등등을 @Getter, @Setter 같은 어노테이션을 통해 자동으로 생성해주는 라이브러리 이다. 공식홈페이지 시작하기라이브러리 의존성 설정Maven12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle1provided 'org.projectlombok:lombok:1.18.4' AssertJ 메소드 임포트1import lombok.*; Lombok 어노테이션 @어노테이션 설명 세부기능 @Getter, @Setter Getter, Setter 메소드 자동생성 – AccessLevel : 해당 접근 제한자를 설정 – lazy : 동기화를 이용하여 최초 1회만 호출 @ToString ToString 메소드 자동생성 – exclude : 출력하지 않을 필드명 입력 – includeFieldNames : 필등명 생략 여부 설정– callSuper : 상위 클래스 toString호출 여부 설정 @EqualsAndHashCode equals, hashcode 메소드 자동생성 – of : 포함 할 필드, – exclude : 제외 할 필드 @Data @ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor 자동생성 @val equals, hashcode 메소드 자동생성 @NonNull 해당 값이 Null 일경우 NullPointerException을 발생 @Cleanup 자동 리소스 관리 : close() 메소드를 귀찮음 없게 안전하게 호출 @NoArgsConstructor 인자 없는 생성자 생성 @RequriedArgsConstructor 필수 인자만 있는 생성자 생성(다른 생성자가 없을 때에만 만들어짐) @AllArgsConstructor 모든 인자를 가진 생성자 생성 @Value 불편 클래스를 쉽게 생성 @Builder Builder API 처럼 사용 할 수 있도록 지원 @SneakyThrows Exception 발생시 체크된 Throable로 감싸서 전달 @Synchronized 메소드에서 동기화 Lock을 설정 @Log 종류별 로그를 사용할 수 있도록 한다. – 기본 변수명 : Log (Config 파일 만들어서 명칭 변경 가능)– 로그 종류 : @Log, @Slf4j, @CommonLog, XSlf4j, JBossLog 등 실제 사용Lombok 어노테이션을 이용하여 만든 Event Class1234567@Builder @AllArgsConstructor @NoArgsConstructor@Getter @Setter @EqualsAndHashCode(of="id")public class Event &#123; private Integer id; private String name;&#125; 실제로 만들어진 .class파일123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.doohong.restapi.event;public class Event2 &#123; private Integer id; private String name; public static Event2.Event2Builder builder() &#123; return new Event2.Event2Builder(); &#125; public Event2(final Integer id, final String name) &#123; this.id = id; this.name = name; &#125; public Event2() &#123; &#125; public Integer getId() &#123; return this.id; &#125; public String getName() &#123; return this.name; &#125; public void setId(final Integer id) &#123; this.id = id; &#125; public void setName(final String name) &#123; this.name = name; &#125; public boolean equals(final Object o) &#123; if (o == this) &#123; return true; &#125; else if (!(o instanceof Event2)) &#123; return false; &#125; else &#123; Event2 other = (Event2)o; if (!other.canEqual(this)) &#123; return false; &#125; else &#123; Object this$id = this.getId(); Object other$id = other.getId(); if (this$id == null) &#123; if (other$id != null) &#123; return false; &#125; &#125; else if (!this$id.equals(other$id)) &#123; return false; &#125; return true; &#125; &#125; &#125; protected boolean canEqual(final Object other) &#123; return other instanceof Event2; &#125; public int hashCode() &#123; int PRIME = true; int result = 1; Object $id = this.getId(); int result = result * 59 + ($id == null ? 43 : $id.hashCode()); return result; &#125; public static class Event2Builder &#123; private Integer id; private String name; Event2Builder() &#123; &#125; public Event2.Event2Builder id(final Integer id) &#123; this.id = id; return this; &#125; public Event2.Event2Builder name(final String name) &#123; this.name = name; return this; &#125; public Event2 build() &#123; return new Event2(this.id, this.name); &#125; public String toString() &#123; Integer var10000 = this.id; return this.name; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>library</tag>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring]빈 등록하기!]]></title>
    <url>%2F2019%2F01%2F09%2FSpring-bean%2F</url>
    <content type="text"><![CDATA[빈 등록 방법빈 등록 방법에는 크게 3가지 방법이 있다 XML을 이용한 빈 등록123&lt;bean id="aaa" class="xxx.yyy.zzz.AAA"&gt; &lt;property name="prop"&gt;&lt;/property&gt;&lt;/bean&gt; 위와 같은 방법으로 xml 설정파일에 직접 등록할 수 있다. 하지만 xml을 통한 빈 등록 방식은 2가지 정도의 문제점이 있다. 빈의 성격 구분을 하기 힘들어진다. 어플리케이션의 크기가 조금만 커져도 빈의 양이 늘어 관리하기 버거울 수 있다. 그래서 스프링에서는 클래스에 특정 애노테이션을 부여하고 부여한 클래스를 찾아 자동으로 빈등록을 해주는 빈 스캐닝 이라는 기능을 제공해준다. Annotation을 이용한 빈 등록빈 등록 Annotation @Component 컴포넌트를 나타내는 일반적인 스테리오 타입으로 태그와 동일한 역할을 함 @Repository 퍼시스턴스 레이어, 영속성을 가지는 속성(파일, 데이터베이스)을 가진 클래스 @Service 서비스 레이어, 비지니스 로직을 가진 클래스 @Controller 프리젠테이션 레이어, 웹 어플리케이션에서 웹 요청과 응답을 처리하는 클래스 @Repository, @Service, @Controller는 더 특정한 유즈케이승 대한 @Component의 구체화된 형태이다. 빈 의존관계 주입 Annotation @Autowired 정밀한 의존관계 주입이 필요한 경우에 유용. @Autowired는 프로퍼티, setter 메서드, 생성자, 일반 메서드에 적용 가능. 의존하는 객체를 주입할 때 주로 Type을 이용 @Resource 어플리케이션에서 필요로 하는 자원을 자동 연결할 때 사용 @Resource는 poperty, setter 메서드에 적용 가능 의존하는 객체를 주입할 때 주로 Name을 이용 @Value 단순한 값을 주입할 때 사용되는 annotation. @Value(“Spring”)은 와 동일한 역할 @Qualifier @Qualifier는 @Autowired annotation과 같이 사용. @Autowired는 타입으로 찾아서 주입하므로, 동일 타입의 Bean 객체가 여러 개 존재할 때 특정 Bean을 찾기 위해 사용 @Component를 통해 자동으로 Bean을 등록하고, @Autowired로 의존관계를 주입받는 어노테이션을 클래스에서 선언하여 사용했을 경우에는 해당 클래스가 위치한 특정 패키지를 Scan하기 위한 설정을 XML에 해야함. 1&lt;context:component-scan base-package="패키기 경로" /&gt; 다음과 같은 태그를 넣어 주기만 하면 dev.wedding.kr.test패키지 하위에 존재하는 빈 스캔 대상(스테레오 타입 내오테이션 클래스)을 빈 으로 등록해준다. 자바 코드로 빈 등록스프링 3.0 부터 기존의 xml 방식을 벗어나 java로 설정 파일을 작성할 수 있게 되었다. java로 설정파일을 작성하게 되면 IDE의 기능을 최대한 활용할 수 있기 때문에작성하기도 쉽고, 이해하기도 쉬워진다. 게다가 IDE에서 문법 체크를 지원해주므로 실수할 일도 줄어들게 된다.1234567891011121314@Configurationpublic class ConfigurationBeanFactory &#123; @Bean public CarInfoProvider kiaCar()&#123; return new KiaCar(); &#125; @Bean public CarInfoProvider hyundaiCar()&#123; return new HyundaiCar(); &#125; &#125; 래스 레벨에서는 @Configuration을 붙이고, 메서드 레벨에서는 @Bean애노테이션을 붙이면 된다. @Bean이 붙은 메서드명이 각각의 bean의 이름이 된다. 리턴되는 객체를 스프링 컨테이버가 빈으로 활용한다.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
        <tag>Bean</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring]IoC 와 DI란]]></title>
    <url>%2F2019%2F01%2F08%2FSpring-IoCDI%2F</url>
    <content type="text"><![CDATA[IoC(Inversion of Control)IoC는 번역하면 제어의 역전 이라는 뜻이다. 일반적인 프로그램은 자신이 사용할 오브젝트를 직접 선택하고 생성한다. ex) new Class(); 오브젝트의 대한 제어권을 자신이 가지고 있는 능동적인 상태인 것이다. 하지만 스프링에서는 프로그램의 흐름을 프레임워크가 주도하게 된다. ex) @Autowired 등으로 Bean을 자동 주입 즉, 제어권이 컨터에너로 넘어가게 되고 이것을 제어권의 흐름이 바뀌었다고 해서 IoC(Inversion of Control : 제어의 역전)이라고 한다. 제어권이 컨테이너로 넘어옴으로써 DI(의존성 주입), AOP(관점 지향 프로그래밍)등이 가능하게 된다. DI(Dependency Injection)DI는 번역하면 의존성 주입 이라는 뜻이다. 객체간의 의존성을 자신이 아닌 외부에서 주입하는 개념이다. 객체지향에서 의존하고 있다라는 의미는 하나의 오브젝트에서 다른 오브젝트를 사용할때를 말한다. A라는 클래스에서 B라는 클래스를 사용할 경우 A클래스는 B클래스에 의존하고 있다고 표현한다. B클래스를 생성해서 A클래스에 넣어주는 과정, 이를 의존성 주입이다. 주입은 제 3자가 해준다. IoC의 개념이다. 결국 DI는 IoC의 세부적인 개념이다!.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
        <tag>IoC</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring]Spring Framework]]></title>
    <url>%2F2019%2F01%2F07%2FSpring-summary%2F</url>
    <content type="text"><![CDATA[Spring Framework란? java 엔터프라이즈 개발 을 편리하게 해주는 오픈소스 경량급 애플리케이션 프레임워크이다. 애플리케이션 프레임워크 특정 계층이나 기술, 업무 분야에 국한되지 않고 애플리케이션 전 영역을 포괄하는 범용적인 프레임 워크 경량급 프레임워크 단순한 웹컨테이너에서도 엔터프라이즈 개발의 고급 기술을 대부분 사용할 수 있다. 엔터프라이즈 개발 용이 개발자가 복잡하고 실수하기 쉬운 Low Level(보안,인증)에 많이 신경 쓰지 않으면서 Business Logic 개발에 전념할 수 있도록 해준다. 오픈소스 Spring은 Open Source 의 장점을 충분히 취하면서 동시에 Open Source 제품의 단점과 한계를 잘 극복한다. Spring Framework 전략 Protable Service Abstraction DI AOP POJO Protable ServiceAbstraction(서비스 추상화)트랜잭션 추상화, OXM 추상화, 데이터 액세스의 Exception 변환기능 등 기술적인 복잡함은 추상화를 통해 Low Level의 기술 구현 부분과 기술을 사용하는 인터페이스로 분리한다. DI(Dependency Injection)Spring은 객체지향에 충실한 설계가 가능하도록 단순한 객체 형태로 개발할 수 있고, DI는 유연하게 확장 가능한 객체를 만들어 두고 그 관계는 외부에서 다이내믹하게 설정해준다. AOP(Aspect Oriented Programming)AOP는 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술 POJO(Plain Old Java Object)POJO는 객체지향 원리에 충실하면서, 특정 환경이나 규약에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 객체 Spring Framework 특징 컨테이너 역할 Spring 컨테이너는 Java 객체의 Life Cycle을 관리하며, Spring 컨테이너로 부터 필요한 객체를 가져와 사용할 수 있다. DI(Dependency Injection)지원 Spring은 설정 파일이나 어노테이션을 통해서 객체간의 의존관계를 설정할 수있다. AOP 지원 Spring은 트랜잭션이나 로깅, 보안과 같이 공통적으로 필요로 하는 모듈들을 실제 핵심 모듈에서 분리해서 적용할 수 있다. POJO 지원 Spring 컨테이너에 저장되는 Java객체는 특정한 인터페이스를 구현하거나, 특정 클래스를 상속받지 않아도 된다. 트랜잭션 처리를 위한 일관된 방법을 지원 JDBC, JTA 등 어떤 트랜잭션을 사용하던 설정을 통해 정보를 관리하므로 트랜잭션 구현에 상관없이 동일한 코드 사용가능 영속성(persistence)과 관련된 다양한 API 지원 Spring은 MyBatis, Hibernate 등 데이터베이스 처리를 위한 ORM(Object Relational Mapping) 프레임워크들과의 연동 지원]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OOP]다형성과 추상화]]></title>
    <url>%2F2019%2F01%2F04%2FOOP-polymorphism%2F</url>
    <content type="text"><![CDATA[객체 지향 프로그래밍 입문 - 최범균님의 인프런 강좌을 보고 작성하였습니다. 다형성(Polymorphism)여러(poly) 모습(morph)을 갖는것 객체 지향에서는 한 객체가 여러 타입을 갖는 것 즉 한 객체가 여러 타입의 기능을 제공 타입 상속으로 다형성 구현 추상화(Abstraction)데이터나 프로세스 등을 의미가 비슷한 개념이나 의미 있는 표현으로 정의하는 과정 두 가지 방식의 추상화 특정한 성질, 공통 성질(일반화) 타입 추상화여러 구현 클래스를 대표하는 상위 타입 도출 흔히 인터페이스 타입으로 추상화 추상화 타입과 구현은 타입 상속으로 연결 추상 타입 사용에 따른 이점 : 유연함추상홪는 의존 대상이 변경하는 시점에추상화 -&gt; 추상 타입 증가 -&gt; 복잡도 증가 아직 존재하지 않는 기능에 대한 이른 추상화는 주의 잘못된 추상화 가능성, 복잡도만증가 실제 변경, 확장이 발생할 때 추상화 시도 추상화를 잘 하려면구현을 한 이유가 무엇 때문인지 생각해야 함]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag> Object-Oriented Programming</tag>
        <tag>Abstraction</tag>
        <tag>Polymorphism</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OOP]상속(Inheritance)이란?]]></title>
    <url>%2F2019%2F01%2F03%2FOOP-Inheritance%2F</url>
    <content type="text"><![CDATA[객체 지향 프로그래밍 입문 - 최범균님의 인프런 강좌을 보고 작성하였습니다. 상속(Inheritance)이란상위 클래스의 기능을 재사용, 확장하는 방법 상속을 통한 기능 재사용시 발생할 수 있는 단점 상위 클래스 변경 어려움 클래스 증가 상속 오용 상속의 단점 해결 방법은 -&gt; 조립!! 조립(Composition)여러 객체를 묶어서 더 복잡한 기능을 제공 보통 필드로 다른 객체를 참조하는 방식으로 조립 또는 객체를 필요 시점에 생성/구함 특정 기능을 재사용 하고 싶다면 특정 객체를 생성하여 사용 상속보다는 조립상속하기에 앞서 조립으로 풀 수 없는지 검토 진짜 하위 타입인 경우에만 상속 사용]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag> Object-Oriented Programming</tag>
        <tag>Inheritance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OOP]캡슐화( encapsulation)란?]]></title>
    <url>%2F2019%2F01%2F02%2FOOP-encapsulation%2F</url>
    <content type="text"><![CDATA[객체 지향 프로그래밍 입문 - 최범균님의 인프런 강좌을 보고 작성하였습니다. 캡슐화(encapsulation)란?캡슐화(encapsulation)는 일반적으로 연관 있는 변수와 함수를 클래스로 묶는 작업을 말한다. 객체가 기능을 어떻게 구현 했는지 외부에 감추는 것 구현에 사용된 데이터의 상세 내용을 외부에 감춤 캡슐화만 잘해도 좋은 코드를 만들 수 있음 정보은닉(Information Hiding) 의미 포함(최근에 포함해서 이야기 많이함) 캡슐화의 장점외부에 영향 없이 객체 내부 구현 변경 가능 클래스 내부 메소드의 구현만 변경하면 되게끔 -&gt; 외부 소스코드의 연쇄적인 변경 x 캡슐화를 잘 할수 있는 규칙!!Tell, Don’t Ask 규칙= 데이터를 달라고 부탁하지 말고 직접 해달라고 하기!Demeter’s Law 규칙 메서드에서 생성한 객체의 메서드만 호출 파라미터로 받은 객체의 메서드만 호출 필드로 참조하는 객체의 메서드만 호출 acc.getExpDate().isAfter(now) -&gt; acc.isExpired();Date date = acc.getExpDate(); date.isAfter(now); -&gt; acc.isValid(now);]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag> Object-Oriented Programming</tag>
        <tag> encapsulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OOP]객체 지향 프로그램 이란?]]></title>
    <url>%2F2019%2F01%2F01%2FOOP-summary%2F</url>
    <content type="text"><![CDATA[객체 지향 프로그래밍(Object-Oriented Programming) 객체 지향 프로그래밍 이란 기존 절차 지향 프로그래밍 기법만의 유지보수와 기존 소프트웨어 재사용이 어려움에 좀더 나은 프로그램을 만들기 위한 프로그래밍 패러다임이다. 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. 객체 지향 프로그래밍은 인간중심적 프로그래밍 패러다임이다. 유지보수와 재사용성이 높다. software maintenance is not “keep it working like before.” It is “keep being useful in a changing world” -jessica Kerr 객체지향 VS 절차지향객체지향 데이터와 프로시저를 알맞게 묶음 설계에 많은 시간이 투자된다. 유지보수 및 업그레이드가 쉽다. 절차지향 데이터가 여로 프로시저를 이용 객체지향에 비해 쉽다. 이러한 데이터를 공유하는 방식은 변화가 필요할 때 수정을 복잡하게 만든ㄴ다. 객체 객체란 데이터와 기능을 가진 물리적으로 존재하거나 추상적으로 생각 할 수 있는 것. 객체의 핵심 -&gt; 기능제공 객체는 제공하는 기능으로 정의 내부적으로 가진 필드로 정의 하지 않음 클래스(Class)클래스는 특정한 기능을 가진 객체를 생성하게 해주는 설계도라고 할 수 있다.클래스로 부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다. 클래스에는 객체에 포함될 변수와 메소드를 정의해야 한다.]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag> Object-Oriented Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-5.접근제어자]]></title>
    <url>%2F2018%2F03%2F05%2FJava-AccessModifier%2F</url>
    <content type="text"><![CDATA[접근제어자(Access Modifier)접근제어자는 변수나 메소드, 클래스에 대한 접근을 제어하는 문법이다. 접근을 제어하는 이유는 객체가 가진 고유의 멤버 변수값들이 외부에서 잘못 변경되는 것을 막기 위해서 이다. 자바에는 다음과 같은 접근제어자가 있다. private default protected public private접근제어자가 private 으로 설정 되어 있다면 그 변수나 메소드는 해당 클래스에만 접근이 가능하다. 최상위 클래스 선언에서는 private를 사용할 수 없다. default접근제어자를 별도로 설정하지 않는다면 default 접근제어자가 된다. default 접근제어자는 해당 패키지 내에서 접근이 가능하다. protectedprotected 접근제어자는 default 접근제어자와 마찬가지로 동일 패키지내에서 접근이 가능하며 추가적으로 해당 클래스를 상속받은 외부 패키지의 클래스에서도 접근이 가능하다. publicpublic 접근제어자는 모든 클래스에 의해 접근할 수 있다. 즉 접근 제약이 없다. 접근 권한 종류 클래스 하위클래스 동일패키지 모든클래스 private O X X X default O X O X protected O O O X public O O O O public &gt; protected &gt; default &gt; private 꿀팁메소드를 오버라이딩 할 경우 부모 클래스의 메소드의 접근제어자보다 좁아질 수는 없다. 그러나 확장될 수는 있다. private 로 선언된 메소드를 public 으로 오버라이딩하여 모든곳에서 접근 가능하도록 수정이 가능하다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>AccessModifier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-4.String pool]]></title>
    <url>%2F2018%2F03%2F04%2Fjava-string-pool%2F</url>
    <content type="text"><![CDATA[String 에 대한 더 자세한 설명이전 포스트에서 말했듯이 String 객체의 값은 변경할 수 없다.나는 String 객체의 값을 변경 시킬수 있다고 생각하시는 분들을 위해 아래 예제를 통해 설명하겠다.123String a = "Hello";a = a+" World";System.out.println(a); //Hello World 이 예제를 보면 a가 참조하는 메모리의 Hello 라는 값에 World 라는 문자열을 더해서 String 객체의 값을 변경 시킨 것으로 보인다 하지만 실제로는 메모리에 Hello World 를 다시 만들고 a를 다시 참조하게 한다. 간단하게 String 클래스의 immutable(불변) 에 대하여 복습 하였다. String pool 이란??String은 자바 개발자라면 자주 쓰게되는 자료형 이다.간혹 자바에서 ==연산자를 이용해서 문자열을 비교하려고 할때 원치 않는 결과를 얻었던 경험들이 있을 것이다. 스트링은 두가지 생성 방식이 있고 그에 따라 각각 차이점이 존재한다. new 연산자를 이용한 방식 리터럴을 이용한 방식 new를 통해 String을 생성하면 Heap영역에 존재하게 되고 리터럴을 이용할 경우 String constant pool이라는 영역에 존재하게 된다. 예제를 통해 쉽게 설명해 보도록 하겠다. 12345String a = "Hello";String b = "Hello";String c = new String("Hello");System.out.println(a==b); //trueSystem.out.println(a==c); //false 위에 예제의 결과에서 왜 3가지 객체가 다 같은 값을 가지고 있음에도 불구하고 비교 결과가 다른지 의문을 가진 분들이 있을것이다. 우선 == 연산은 값을 비교하는것이 아니라 같은 메모리를 참조하는지 비교하는 것이다. a의 경우 Hello 라는 문자열을 String pool 에 넣게 된다. b의 경우는 이미 같은 문자열이 String pool 에 존재하기에 같은 값을 참조하게 된다. c의 경우에는 new 연산자를 사용하여 새로운 객체를 명시적으로 생성하도록 했기 때문에 String pool이 아닌 다른 주소값을 참조하게된다. 이러한 이유로 위와 같은 결과를 얻을 수 있다. 이 예제를 통해 왜 String 객체의 값을 변경할 수 없어야 하는지 이유도 알 수 있다.만약에 String 객체의 값의 변경이 가능하다면 a의 값을 변경 하였을때 원치 않게 b의 값도 변경될 수 있다. String 객체의 값을 비교하는 equals()equals() 메소드를 이용하여 두 문자열 객체의 실제 값을 비교할 수 있다. 그렇기 때문에 문자열 비교는 equals() 를 사용하는 것이 좋지만 속도적인 부분이나 메모리 부분 때문에 ==을 사용해야한다면 방법은 있다. intern() 메소드를 사용하는 방법이다. intern()12345678910111213141516171819String a = "Hello";String b = new String("Hello");String c = b.intern();System.out.println(a.equal(b)); // trueSystem.out.println(a==c); // true``` **intern()** 메소드를 사용하면 해당 리터럴이 pool 에 존재하는지 화가인하고 존재하면 해당 pool 에 있는 리터럴을 리턴하고 없다면 리터럴을 pool 에 집어넣는다.그렇기 때문에 c의 경우는 String c = "Hello" 로 해석할 수 있고 pool 에 이미 a가 만든 Hello 가 존재하므로 a와 같은 주소를 참조하게 된다.아마도 **intern()** 메소드보다 **equals()** 메소드를 더 많이 사용하게 되겠지만 만약 사용하게 된다면 아래와 같이 사용할 수 있지 않을까 싶다.```javaString id = "user";String compareId = UserDto.getId().intern();if(id == user)&#123; ...&#125; 그냥 이렇게도 사용할 수 있지 않을까 싶어 내가 만든 예시이다. 속도나 메모리를 엄청 신경 써야 하지 않는다면 문자열 비교는 equals()로 습관화 하는것이 좋은 방법일것 같다. String pool 의 위치String pool 은 java 6 버전까지 Perm 영역이었다. 하지만 Perm 영역은 고정된 사이즈이며 Runtime 에 사이즈가 확장되지 않는다 그래서 intern 되는 String 값이 커지면 OutOfMemoryException을 발생시킬 수 있었고 그에따라 java 7 버전에서 heap 영역으로 String pool 의 위치를 변경하였다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>String</tag>
        <tag>StringPool</tag>
        <tag>intern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-3.String, StringBuffer, StringBuilder]]></title>
    <url>%2F2018%2F03%2F03%2Fjava-string%2F</url>
    <content type="text"><![CDATA[String, StringBuffer, StringBuilder 의 특징String, StringBuffer, StringBuilder 이 세가지 클래스들은 모두 문자열 처리를 위한 클래스 이다. 대부분의 자바를 처음 공부하는 사람들은 문자열 처리를 위해서 String 클래스만을 사용하며 조금더 공부하여 StringBuffer 클래스를 알게되면 정확한 차이를 모르는채 성능 향상이라는 이유로 StringBuffer 클래스를 자주 사용한다. 그렇다면 이 세가지 클래스에 정확한 차이점을 알아보고 상황에 맞게 잘 사용해 보도록 하자 String 클래스String 클래스와 다른 2개의 클래스와의 가장 큰 차이점은 String 클래스는 immutable(불변) 하고 StringBuffer, StringBuilder 클래스는 mutable(가변) 한다는 점이다. 이게 무슨 말인지 쉽게 설명 하자면 String 객체는 한번 생성되면 할당된 메모리 공간이 변하지 않는다. +연산자 또는 문자열에 변화를 줘도 메모리 공간이 변하는 것이 아니라 새로운 String 객체를 만든 후, 새 String 객체에 연결된 문자열을 저장하고 그객체를 참조하도록 한다. 변경되기 전의 문자열은 더이상 어느곳에서도 참조하지 않게 되면 가비지 콜렉터(언제 제거될지 모름)에 의해 제거 된다. 이러한 이유로 String 객체는 문자열 연산이 많아질 때 성능이 떨어질 수 밖에 없는 단점이 있다. 그렇다면 왜 이러한 단점을 가지면서도 immutable(불변) 클래스인 String 클래스를 기본 문자열처리 클래스로 정했을까? immutable(불변) 클래스의 가장 큰 장점은 안전하게 공유될 수 있다는 점이다. 즉, 변경은 적고 읽기만 많은 경우, 또는 여러 쓰레드나 객체에서 공유하는 경우, synchronization(동기화)와 같은 특별한 안전장치 없이도 안전하게 공유 될수 있다. 대부분의 문자열이 복잡한 문자열 처리과정보다는 한번 설정된 문자열들을 여러 곳에서 공유하는 경우가 많으므로, 자바에서 기본 문자열을 처리하는 클래스로 String 클래스를 immutable 패턴으로 설정하였다. StringBuffer, StringBuilder 클래스StringBuffer, StringBuilder 클래스는 String 과 다르게 mutable(가변) 클래스이다. 즉 문자열 연산에 있어서 클래스를 한번만 만들고 연산이 필요할 때 크기를 변경시켜 문자열을 변경한다. 이 경우 객체를 새로 생성하지 않는다. 그러므로 문자열 연산이 자주 있을 때 String 클래스 대신 사용하면 성능이 좋다는 장점이 있다. StringBuilder는 JDK 5.0 에서 새로 추가된 클래스이다.두 클래스에서 제공하는 메소드는 동일하다. 차이점은 StringBuffer는 멀티쓰레드환경에서 synchronized키워드가 가능하므로 동기화가 가능하다. 즉, thread-safe하다. StringBuilder는 동기화를 지원하지 않기 때문에 멀티쓰레드환경에서는 적합하지 않다. 대신 StringBuilder가 동기화를 고려하지 않기 때문에 싱글쓰레드 환경에서 StringBuffer에 비해 연산처리가 빠르다. String, StringBuffer, StringBuilder 선택 기준 String 객체는 불변이기 때문에 변하지 않는 문자열은 String을 사용한다. StringBuilder는 비동기방식이기 때문에 Single Thread 환경하에서, 변화되는 문자열의 사용한다. StringBuffer 동기방식으로 저장되기 때문에 멀티쓰레드로 접근하거나 문자열이 변경될 경우에 사용한다. JDK 버전에 따른 차이JDK 1.5버전 이후에는 컴파일 단계에서 String 객체를 사용하더라도 StringBuilder로 컴파일 되도록 변경 되었다. 그렇기 때문에 String 클래스를 활용해도 성능차이가 없어지긴 하였지만 반복 루프를 사용해 문자열을 더할때 객체를 게속 추가하는 사실에는 변함이 없다. 따라서 String 클래스를 쓰는 대신, 스레드와 관련이 있으면 StringBuffer를, 스레드 안전 여부와 상관이 없으면 StringBuilder를 사용하는 것을 권장한다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-2.자바 메모리 구조]]></title>
    <url>%2F2018%2F03%2F02%2FJava-runtime-data-area%2F</url>
    <content type="text"><![CDATA[Runtime Data Area JVM이 프로그램을 수행하기 위해 운영체제로부터 할당 받는 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 이 영역은 각각의 목젝에 따라 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있다. Method Area(메소드 영역) 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 메소드 정보, Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수등이 생성되는 영역이다. 프로그램이 실행되면 모든 코드가 저장되어 있는 상태가 아니다. new 키워드를 통해 객체가 동적으로 생성되기 이전에는 텍스트 일 뿐이다. 객체 생성 후에 메소드를 실행하게 되면 해당 클래스 코드에 대한 정보를 Method Area에 저장 하게 된다. Heap area(힙 영역) 사용자가 관리하는 인스턴스가 생성되는 공간으로 객체를 동적으로 생성하면 인스턴스가 Heap 영역의 메모리에 할당되어 사용되어진다. 프로그램은 시작될 때 미리 Heap 영역을 많이 할당해 놓으며 인스턴스와 인스턴스 변수가 저장된다. 레퍼런스 변수의 경우 Heap에 인스턴스가 저장 되는것이 아니라 포인터가 저장된다. 메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다. Stack area (스택 영역) 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다. int x = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 x라고 잡아두고 그 메모리 영역에 값이 10이 들어간다. 즉, 스택에 메모리에 이름이 x라고 붙여주고 값이 10인 메모리 공간을 만든다. Animal dog = new Animal(); 이라는 코드를 작성했다면 Animal dog은 스택 영역에 생성되고 new로 생성된 Animal클래스의 인스턴스는 힙 영역에 생성된다. 스택영역에 생성된 dog의 값으로 힙 영역의 주소값을 가지고 있다. 즉 스택 영역에 생성된 dog가 힙 영역에 생성된 객체를 참조하고 있는 것이다. PC Register (PC 레지스터) PC Registers는 Thread가 생성될 때 마다 생기는 공간으로 Thread가 어떠한 명령을 실행하게 될지에 대한 부분을 기록을 한다. JVM은 Stacks-Base 방식으로 작동 하는데, JVM은 CPU에 직접 Instruction을 수행하지 않고, Stack에서 Operand를 뽑아내 이를 별도의 메모리 공간에 저장하는 방식을 취하는데, 이러한 메모리 공간을 PC Registers라고 한다. Native method stack 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다. 보통 C/C++등의 코드를 수행하기 위한 스택이다. JNI를 통해 표준에 가까운 방식으로 구현이 가능하다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-1.자바란?]]></title>
    <url>%2F2018%2F03%2F01%2FJava-summary%2F</url>
    <content type="text"><![CDATA[자바 언어의 이해자바 자바는 썬 마이크로시스템즈에서 제임스 고슬링이 다른 연구원들과 함꼐 고안한 오크(Oak)라는 언어에서 시작되었다. 오크는 가전제품에서 사용될 목적이었으나, 인터넷이 발전하면서 인터넷 친화적 언어로 사용되었고 1995년 ‘자바’로 이름을 변경하였다. 1995년~1999년까지는 윈도우 프로그램 개발이 주류여서 C++언어에 비해 자바는 열세였지만 1999년도부터 자바는 활성화 되었고 현재 자바는 IT기술 전반에서 가장 널리 사용하는 프로그래밍 언어가 되었다. 자바 프로그래밍자바의 프로그램의 실행 과정은 다음과 같다. 자바 컴파일러(Java compiler) Java를 가지고 작성한 자바 소스 코드를 자바 가상 머신이 이해할 수 있는 자바 바이트 코드로 변환한다. 자바 컴파일러는 자바를 설치하면 javac.exe라는 실행 파일 형태로 설치 된다. 자바 바이트 코드(Java bytecode) 자바 바이트 코드란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다. 자바 컴파일러에 의해서 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불린다. 자바 바이트 코드의 확장자는 .class 이다. 자바 바이트 코드는 자바 가상 머신이 설치되어 있다면 어떤 운영체제에서라도 실행 될 수 있다.JVM JVM이란 JAVA Virtual Machine의 약자로 자바 가성 머신을 줄여 부르는 용어이다. 자바 컴파일러를 통해 바이트코드를 생성한다. 바이트코드는 하드웨어에 종속적이지 않은 중간 파일로, JVM은 이러한 바이트코드를 실행 시키기 위한 가상의 기계라고 할 수 있다. JVM이 설치되어 있으면 서로 다른 기기나 운영체제에서 동일하게 프로그램을 실행할 수 있다. JVM의 구성자바 가상 머신(JVM)은 다음과 같이 구성된다. 자바 인터프리터(interpreter) 클래스 로더(class loader) JIT 컴파일러 (Just-In-Time compiler) 가비지 컬렉터(garbage collector) 자바 컴파일러에 의해 변환된 자바 바이트 코드를 읽고 해석하는 역할을 하는 것이 자바 인터프리터(interpreter)이다. 자바는 동적으로 클래스를 읽어오므로, 프로그램이 실행 중인 런타임에서야 모든 코드가 자바 가상머신과 연결된다. 이렇게 동적으로 클래스를 로딩해주는 역할을 하는 것이 바로 클래스 로더(class loader)이다. JIT 컴파일러 (Just-In-Time compiler)란 프로그램이 실행 중인 런타임에 실제 기계어로 변환해 주는 컴파일러를 의미한다. 동적 번역(dynamic translation)이라고도 불리는 이 기법은 프로그램의 실행 속도를 향상시키기 위해 개발되었습니다.즉, JIT 컴파일러는 자바 컴파일러가 생성한 자바 바이트 코드를 런타임에 바로 기계어로 변환하는데 사용된다. 자바 가상 머신은 가비지 컬렉터(garbage collector)를 이용하여 더는 사용하지 않는 메모리를 자동으로 회수해 준다. 따라서 개발자가 따로 메모리를 관리하지 않아도 되므로, 더욱 손쉽게 프로그래밍을 할 수 있도록 도와준다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
