<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F12%2FREST-API-2%2F</url>
    <content type="text"><![CDATA[title: REST API 만들기-2 #글 제목 date: 2019-01-25 18:00:00 #작성일 tags: [“RESTAPI”,”REST”,”API”] categories: RESTAPI #태그 스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. Event 생성 APITDD를 위한 테스트 작성테스트 할것입력값들을 전달하면 JSON 응답으로 201이 나오는지 확인. Location 헤더에 생성된 이벤트를 조회할 수 있는 URI 담겨 있는지 확인. id는 DB에 들어갈 때 자동생성된 값으로 나오는지 확인 EventControllerTest 클래스 생성12345678910111213141516171819202122232425262728293031323334@RunWith(SpringRunner.class)@WebMvcTest //web과 관련된 빈들이 등록 됨public class EventControllerTests &#123; @Autowired MockMvc mockMvc; // 가짜 요청을 만들어 DispatcherServlet 에게 보내고 응답을 확인(웹서버를 띄우진 않음) @Autowired ObjectMapper objectMapper; //자동으로 빈으로 등록해줌 @Test public void createEvent()&#123; Event event = Event.builder() .name("Spring") .description("REST API Development with Spring") .beginEnrollmentDateTime(LocalDateTime.of(2018,11,23,14,22)) .closeEnrollmentDateTime(LocalDateTime.of(2018,11,24,14,22)) .beginEventDateTime(LocalDateTime.of(2018,11,25,14,22)) .endEventDateTime(LocalDateTime.of(2018,11,26,14,22)) .basePrice(100) .maxPrice(200) .limitOfEnrollment(100) .location("강남역 D2 스타텁 팩토리") .build(); mockMvc.perform(post("/api/events") .contentType((MediaType).APPLICATION_JSON_UTF8) .accepot(MediaTypes.HAL_JSON) .content(objectMapper.writeValueAsString(event))) .andDo(print()) .andExpect(status().isCreated() .andExpect(jsonPath("id").exists()); &#125; &#125; @WebMvcTest MockMvc 빈을 자동 설정 웹 관련 빈만 등록.(슬라이스) MockMvc 스프링 MVC 테스트 핵심클래스 웹 서버를 띄우지 않고도 스프링 MVC(DispatcherServlet)가 요청을 처리하는 과정을 확인할 수 있기 때문에 컨트롤러 테스트용으로 자주 쓰임 ObjectMapper 스프링 부트에 mapping Jackson이 의존성주입이 되있을경우 자동 빈등록 objectMapper.writeValueAsString(event) 객체를 JSON으로 변환! EventController 클래스 작성12345678910@RequestMapping(value ="/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE )public class EventController&#123; @PostMapping public ResponseEntity createEvent(@RequestMapping Event event)&#123; URI createdUri = linkTo(EventController.class).slash("&#123;id&#125;").toUri(); event.setID(10); //우선 임의로 아이디값을 준다. return ResponseEntity.created(createdUri).body(event); &#125;&#125; 테스트를 진행하면 정상적으로 실행이 된다.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F12%2FREST-API-3%2F</url>
    <content type="text"><![CDATA[title: REST API 만들기-3 #글 제목 date: 2019-01-26 18:00:00 #작성일 tags: [“RESTAPI”,”REST”,”API”] categories: RESTAPI #태그 스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. event 객체를 실제 DB에 저장 시키기Event 클래스 수정12345678910@Builder @AllArgsConstructor @NoArgsConstructor@Getter @Setter @EqualsAndHashCode(of="id")@Entitypublic class Event &#123; @Id @GeneratedValue private Integer id; ... @Enumerated(EnumType.STRING) //string을 더 권장 private EventStatus eventStatus = EventStatus.DRAFT; Event 클래스 각 위치에 @Entity @ID @GeneratedValue @Enumerated 어노테이션을 추가해준다. @Entity 이 어노테이션은 해당 클래스가 엔티티임을 알리기 위해 사용합니다. 애플리케이션이 실행이 될 때 엔티티 자동검색을 통하여 이 어노테이션이 선언 된 클래스들은 엔티티 빈으로 등록합니다. @Id 엔티티빈의 기본키를 의미합니다. 이 어노테이션은 하나의 엔티티에는 반드시 하나가 존재해야 합니다. @GeneratedValue 데이터베이스에 의해 자동으로 생성된 값이라는 의미입니다. 즉, 프로그램 상에서 조작된 데이터가 아닌, 실제 데이터베이스에 데이터가 영속(저장)될 때 생성되는 값입니다.@Enumerated(EnumType.STRING) EnumType.ORDINAL을 이용하면 Enum 순서 값을 DB에 저장합니다 EnumType.STRING을 이용하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장됩니다.EventRepository 인터페이스 작성123public interface EventRepository extends JpaRepository&lt;Event,Integer&gt; &#123;&#125; EventController 클래스 수정123456789101112@RequestMapping(value ="/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE )public class EventController&#123; public EventController(EventRepository eventRepository)&#123; this.eventRepository = eventRepository; &#125; @PostMapping public ResponseEntity createEvent(@RequestMapping Event event)&#123; Event newEvent = this.eventRepository.save(event); //JPA를 이용한 저장 URI createdUri = linkTo(EventController.class).slash(newEvent.getId()).toUri(); //DB에 저장되며 생성된 ID값을 이용 return ResponseEntity.created(createdUri).body(event); &#125;&#125; EventControllerTests 클래스 수정12345678910111213141516171819202122232425@RunWith(SpringRunner.class)@WebMvcTest //web과 관련된 빈들이 등록 됨public class EventControllerTests &#123; @MockBean EventRepository eventRepository; @Test public void createEvent() throws Exception&#123; ... event.setId(10); Mockito.when(eventRepository.save(event)).thenReturn(event); mockMvc.perform(post("/api/events") .contentType(MediaType.APPLICATION_JSON_UTF8) .accept(MediaTypes.HAL_JSON) .content(objectMapper.writeValueAsString(event))) .andDo(print()) .andExpect(status().isCreated()) .andExpect(jsonPath("id").exists()) .andExpect(header().exists(HttpHeaders.LOCATION)) .andExpect(header().string(HttpHeaders.CONTENT_TYPE,MediaTypes.HAL_JSON_UTF8_VALUE)); ... &#125; MockBean MockBean으로 만든 eventRepository는 Mock객체이기때문에 save를 하여도 리턴 값이 null이다. 그렇기 때문에 Mockito를 사용해서 Stubbing 해주었다.]]></content>
  </entry>
  <entry>
    <title><![CDATA[REST API 만들기-1]]></title>
    <url>%2F2019%2F01%2F24%2FREST-API-1%2F</url>
    <content type="text"><![CDATA[스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. 추가할 의존성 및 JDK 버전 Web JPA HATEOAS REST Docs H2 PostgreSQL Lombok JDK 11입력으로 받을 값들 name description beginEnrollmentDateTime closeEnrollmentDateTime beginEventDateTime endEventDateTime location (optional) 이게 없으면 온라인 모임 basePrice (optional) maxPrice (optional) limitOfEnrollment basePrice maxPrice 설명 0 100 선착순등록 0 0 무료 100 0 무제한 경매(높은 금액 낸 사람이 등록) 100 200 제한가 선착순 등록 결과로 줄 값들 name … eventStatus: DRAFT, PUBLISHED, ENROLLMENT_STARTED, … offline free _links profile (for the self-descriptive message) self publish시작하기Event 클래스 만들기.패키지를 하나 만들고 그안에 Event 클래스를 생성한다.이벤트 클래스는 나중에 DB의 테이블과 매칭될 Entity 클래스 이다.123456789101112public class Event &#123; private String name; private String description; private LocalDateTime beginEnrollmentDateTime; private LocalDateTime closeEnrollmentDateTime; private LocalDateTime beginEventDateTime; private LocalDateTime endEventDateTime; private String location; private int basePrice; private int maxPrice; private int limitOfEnrollment;&#125; EventStatus enum 클래스 생성123public enum EventStatus &#123; DRAFT, PUBLISHED, BEGEAN_ENROLLMENT;&#125; Event 클래스에 lombok 어노테이션 추가12@Builder @AllArgsConstructor @NoArgsConstructor@Getter @Setter @EqualsAndHashCode(of="id") Test 클래스를 만들어 junit 테스트12345678910111213141516171819202122232425@Testpublic void builder()&#123; Event event = Event.builder() .name("inflearn") .description("rst API") .build(); assertThat(event).isNotNull();&#125;@Testpublic void JavaBean()&#123; //Given String name = "Event"; String description = "Spring"; //When Event event = new Event(); event.setName("Event"); event.setDescription("Spring"); //Then assertThat(event.getName()).isEqualTo(name); assertThat(event.getDescription()).isEqualTo(description);&#125; Lombok 과 AssertJ의 추가적인 설명 LombokAssertJ]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring-library]AssertJ란?]]></title>
    <url>%2F2019%2F01%2F23%2FSpring-AssertJ%2F</url>
    <content type="text"><![CDATA[AsertJ란? java test를 위해 좀 더 풍부한 문법을 제공하고 메서드 체이닝을 통해 직관적인 테스트 흐름을 작성할 수 있도록 개발된 오픈소스 라이브러리이다. 최근 junit에 필수로 사용되고 있는 추세이다. 공식홈페이지 시작하기라이브러리 의존성 설정Maven1234567&lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;!-- use 2.9.1 for Java 7 projects --&gt; &lt;version&gt;3.11.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Gradle1testCompile("org.assertj:assertj-core:3.11.1") 또는 Java 7 프로젝트의 경우 버전 2.9.11testCompile("org.assertj:assertj-core:2.9.1") AssertJ 메소드 임포트1import static org.assertj.core.api.Assertions.*; 실제 사용1assertThat(objectUnderTest). // code completion -&gt; assertions specific to objectUnderTest 모든 테스트 코드는 assertThat() 메소드에서 시작한다. ###문자열 테스트12345678assertThat("Hello, world! Nice to meet you.") // 주어진 "Hello, world! Nice to meet you."라는 문자열은 .isNotEmpty() // 비어있지 않고 .contains("Nice") // "Nice"를 포함하고 .contains("world") // "world"도 포함하고 .doesNotContain("ZZZ") // "ZZZ"는 포함하지 않으며 .startsWith("Hell") // "Hell"로 시작하고 .endsWith("u.") // "u."로 끝나며 .isEqualTo("Hello, world! Nice to meet you."); // "Hello, world! Nice to meet you."과 일치합니다. 숫자 테스트1234567assertThat(3.14d) // 주어진 3.14라는 숫자는 .isPositive() // 양수이고 .isGreaterThan(3) // 3보다 크며 .isLessThan(4) // 4보다 작습니다 .isEqualTo(3, offset(1d)) // 오프셋 1 기준으로 3과 같고 .isEqualTo(3.1, offset(0.1d)) // 오프셋 0.1 기준으로 3.1과 같으며 .isEqualTo(3.14); // 오프셋 없이는 3.14와 같습니다]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>library</tag>
        <tag>Test</tag>
        <tag>AssertJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring-library]Lombok이란?]]></title>
    <url>%2F2019%2F01%2F23%2FSpring-Lombok%2F</url>
    <content type="text"><![CDATA[Lombok이란? Lombok은 자바에서 Model(DTO, VO, Domain Class) 클래스를 작성할 때, 멤버 변수에 대한 Getter/Setter Method, Equals(), hashCode(), ToString()과 멤버 변수에 값을 설정하는 생성자 등등을 @Getter, @Setter 같은 어노테이션을 통해 자동으로 생성해주는 라이브러리 이다. 공식홈페이지 시작하기라이브러리 의존성 설정Maven12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle1provided 'org.projectlombok:lombok:1.18.4' AssertJ 메소드 임포트1import lombok.*; Lombok 어노테이션 @어노테이션 설명 세부기능 @Getter, @Setter Getter, Setter 메소드 자동생성 – AccessLevel : 해당 접근 제한자를 설정 – lazy : 동기화를 이용하여 최초 1회만 호출 @ToString ToString 메소드 자동생성 – exclude : 출력하지 않을 필드명 입력 – includeFieldNames : 필등명 생략 여부 설정– callSuper : 상위 클래스 toString호출 여부 설정 @EqualsAndHashCode equals, hashcode 메소드 자동생성 – of : 포함 할 필드, – exclude : 제외 할 필드 @Data @ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor 자동생성 @val equals, hashcode 메소드 자동생성 @NonNull 해당 값이 Null 일경우 NullPointerException을 발생 @Cleanup 자동 리소스 관리 : close() 메소드를 귀찮음 없게 안전하게 호출 @NoArgsConstructor 인자 없는 생성자 생성 @RequriedArgsConstructor 필수 인자만 있는 생성자 생성(다른 생성자가 없을 때에만 만들어짐) @AllArgsConstructor 모든 인자를 가진 생성자 생성 @Value 불편 클래스를 쉽게 생성 @Builder Builder API 처럼 사용 할 수 있도록 지원 @SneakyThrows Exception 발생시 체크된 Throable로 감싸서 전달 @Synchronized 메소드에서 동기화 Lock을 설정 @Log 종류별 로그를 사용할 수 있도록 한다. – 기본 변수명 : Log (Config 파일 만들어서 명칭 변경 가능)– 로그 종류 : @Log, @Slf4j, @CommonLog, XSlf4j, JBossLog 등 실제 사용Lombok 어노테이션을 이용하여 만든 Event Class1234567@Builder @AllArgsConstructor @NoArgsConstructor@Getter @Setter @EqualsAndHashCode(of="id")public class Event &#123; private Integer id; private String name;&#125; 실제로 만들어진 .class파일123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.doohong.restapi.event;public class Event2 &#123; private Integer id; private String name; public static Event2.Event2Builder builder() &#123; return new Event2.Event2Builder(); &#125; public Event2(final Integer id, final String name) &#123; this.id = id; this.name = name; &#125; public Event2() &#123; &#125; public Integer getId() &#123; return this.id; &#125; public String getName() &#123; return this.name; &#125; public void setId(final Integer id) &#123; this.id = id; &#125; public void setName(final String name) &#123; this.name = name; &#125; public boolean equals(final Object o) &#123; if (o == this) &#123; return true; &#125; else if (!(o instanceof Event2)) &#123; return false; &#125; else &#123; Event2 other = (Event2)o; if (!other.canEqual(this)) &#123; return false; &#125; else &#123; Object this$id = this.getId(); Object other$id = other.getId(); if (this$id == null) &#123; if (other$id != null) &#123; return false; &#125; &#125; else if (!this$id.equals(other$id)) &#123; return false; &#125; return true; &#125; &#125; &#125; protected boolean canEqual(final Object other) &#123; return other instanceof Event2; &#125; public int hashCode() &#123; int PRIME = true; int result = 1; Object $id = this.getId(); int result = result * 59 + ($id == null ? 43 : $id.hashCode()); return result; &#125; public static class Event2Builder &#123; private Integer id; private String name; Event2Builder() &#123; &#125; public Event2.Event2Builder id(final Integer id) &#123; this.id = id; return this; &#125; public Event2.Event2Builder name(final String name) &#123; this.name = name; return this; &#125; public Event2 build() &#123; return new Event2(this.id, this.name); &#125; public String toString() &#123; Integer var10000 = this.id; return this.name; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>library</tag>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST API란]]></title>
    <url>%2F2019%2F01%2F23%2FREST-API%2F</url>
    <content type="text"><![CDATA[스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. API Application Programming Interface 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. REST REpresentational State Treansfer 인터넷 상의 시스템 간의 상호 운용성(Interoperability)을 제공하는 방법중 하나 시스템 제각각의 독립적인 진화를 보장하기 위한 방법 REST API : REST 아키텍처 스타일을 따르는 API 그런 REST API로 괜찮은가 그런 REST API로 괜찮은가 - 이응준님 강연을 보고 작성하였습니다. 오늘날 대부분의 “REST API”는 사실 REST를 따르지 않고 있다. REST의 제약조건 중에서 특히 Self-descriptive와 HATEOAS를 잘 만족하지 못한다. REST를 따르겠다면, Self-descriptive와 HATEOAS를 만족시켜야한다. Self-descriptive는 custom media type이나 profile link relation 등으로 만족시킬 수 있다. HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.Self descriptive message 메세지 스스로 메세지에 대한 설명이 가능해야 한다. 이렇지 않으면 API문서를 항상 만들어야 한다. API만 보고 의미를 알 수 없기 때문이다. Self descriptive message를 달성하기 위한 방법 미디어 타입을 IANA에 등록하고 그 미디어 타입을 리소스 리턴할 때 Content-Type으로 사용한다. ProFile 의미가 뭔지 정보가 담긴 문서 링크 헤더를 추가한다. HATEOAS 하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 하며 링크 정보를 동적으로 바꿀 수 있다. HATEOS는 애플리케이션 상태 전이의 late binding을 가능하게 하기 때문에 필요하다.어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이될 수 있는 상태가 결정된다. 링크는 동적으로 변경될 수 있다. 언제나 서버가 마음대로 바꿀 수 있음.HATEOAS를 달성하기 위한 방법 데이터 링크 제공 HTTP 헤더에 Location, Link를 활용하는 방법]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring]빈 등록하기!]]></title>
    <url>%2F2019%2F01%2F09%2FSpring-bean%2F</url>
    <content type="text"><![CDATA[빈 등록 방법빈 등록 방법에는 크게 3가지 방법이 있다 XML을 이용한 빈 등록123&lt;bean id="aaa" class="xxx.yyy.zzz.AAA"&gt; &lt;property name="prop"&gt;&lt;/property&gt;&lt;/bean&gt; 위와 같은 방법으로 xml 설정파일에 직접 등록할 수 있다. 하지만 xml을 통한 빈 등록 방식은 2가지 정도의 문제점이 있다. 빈의 성격 구분을 하기 힘들어진다. 어플리케이션의 크기가 조금만 커져도 빈의 양이 늘어 관리하기 버거울 수 있다. 그래서 스프링에서는 클래스에 특정 애노테이션을 부여하고 부여한 클래스를 찾아 자동으로 빈등록을 해주는 빈 스캐닝 이라는 기능을 제공해준다. Annotation을 이용한 빈 등록빈 등록 Annotation @Component 컴포넌트를 나타내는 일반적인 스테리오 타입으로 태그와 동일한 역할을 함 @Repository 퍼시스턴스 레이어, 영속성을 가지는 속성(파일, 데이터베이스)을 가진 클래스 @Service 서비스 레이어, 비지니스 로직을 가진 클래스 @Controller 프리젠테이션 레이어, 웹 어플리케이션에서 웹 요청과 응답을 처리하는 클래스 @Repository, @Service, @Controller는 더 특정한 유즈케이승 대한 @Component의 구체화된 형태이다. 빈 의존관계 주입 Annotation @Autowired 정밀한 의존관계 주입이 필요한 경우에 유용. @Autowired는 프로퍼티, setter 메서드, 생성자, 일반 메서드에 적용 가능. 의존하는 객체를 주입할 때 주로 Type을 이용 @Resource 어플리케이션에서 필요로 하는 자원을 자동 연결할 때 사용 @Resource는 poperty, setter 메서드에 적용 가능 의존하는 객체를 주입할 때 주로 Name을 이용 @Value 단순한 값을 주입할 때 사용되는 annotation. @Value(“Spring”)은 와 동일한 역할 @Qualifier @Qualifier는 @Autowired annotation과 같이 사용. @Autowired는 타입으로 찾아서 주입하므로, 동일 타입의 Bean 객체가 여러 개 존재할 때 특정 Bean을 찾기 위해 사용 @Component를 통해 자동으로 Bean을 등록하고, @Autowired로 의존관계를 주입받는 어노테이션을 클래스에서 선언하여 사용했을 경우에는 해당 클래스가 위치한 특정 패키지를 Scan하기 위한 설정을 XML에 해야함. 1&lt;context:component-scan base-package="패키기 경로" /&gt; 다음과 같은 태그를 넣어 주기만 하면 dev.wedding.kr.test패키지 하위에 존재하는 빈 스캔 대상(스테레오 타입 내오테이션 클래스)을 빈 으로 등록해준다. 자바 코드로 빈 등록스프링 3.0 부터 기존의 xml 방식을 벗어나 java로 설정 파일을 작성할 수 있게 되었다. java로 설정파일을 작성하게 되면 IDE의 기능을 최대한 활용할 수 있기 때문에작성하기도 쉽고, 이해하기도 쉬워진다. 게다가 IDE에서 문법 체크를 지원해주므로 실수할 일도 줄어들게 된다.1234567891011121314@Configurationpublic class ConfigurationBeanFactory &#123; @Bean public CarInfoProvider kiaCar()&#123; return new KiaCar(); &#125; @Bean public CarInfoProvider hyundaiCar()&#123; return new HyundaiCar(); &#125; &#125; 래스 레벨에서는 @Configuration을 붙이고, 메서드 레벨에서는 @Bean애노테이션을 붙이면 된다. @Bean이 붙은 메서드명이 각각의 bean의 이름이 된다. 리턴되는 객체를 스프링 컨테이버가 빈으로 활용한다.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
        <tag>Bean</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring]IoC 와 DI란]]></title>
    <url>%2F2019%2F01%2F08%2FSpring-IoCDI%2F</url>
    <content type="text"><![CDATA[IoC(Inversion of Control)IoC는 번역하면 제어의 역전 이라는 뜻이다. 일반적인 프로그램은 자신이 사용할 오브젝트를 직접 선택하고 생성한다. ex) new Class(); 오브젝트의 대한 제어권을 자신이 가지고 있는 능동적인 상태인 것이다. 하지만 스프링에서는 프로그램의 흐름을 프레임워크가 주도하게 된다. ex) @Autowired 등으로 Bean을 자동 주입 즉, 제어권이 컨터에너로 넘어가게 되고 이것을 제어권의 흐름이 바뀌었다고 해서 IoC(Inversion of Control : 제어의 역전)이라고 한다. 제어권이 컨테이너로 넘어옴으로써 DI(의존성 주입), AOP(관점 지향 프로그래밍)등이 가능하게 된다. DI(Dependency Injection)DI는 번역하면 의존성 주입 이라는 뜻이다. 객체간의 의존성을 자신이 아닌 외부에서 주입하는 개념이다. 객체지향에서 의존하고 있다라는 의미는 하나의 오브젝트에서 다른 오브젝트를 사용할때를 말한다. A라는 클래스에서 B라는 클래스를 사용할 경우 A클래스는 B클래스에 의존하고 있다고 표현한다. B클래스를 생성해서 A클래스에 넣어주는 과정, 이를 의존성 주입이다. 주입은 제 3자가 해준다. IoC의 개념이다. 결국 DI는 IoC의 세부적인 개념이다!.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
        <tag>IoC</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring]Spring Framework]]></title>
    <url>%2F2019%2F01%2F07%2FSpring-summary%2F</url>
    <content type="text"><![CDATA[Spring Framework란? java 엔터프라이즈 개발 을 편리하게 해주는 오픈소스 경량급 애플리케이션 프레임워크이다. 애플리케이션 프레임워크 특정 계층이나 기술, 업무 분야에 국한되지 않고 애플리케이션 전 영역을 포괄하는 범용적인 프레임 워크 경량급 프레임워크 단순한 웹컨테이너에서도 엔터프라이즈 개발의 고급 기술을 대부분 사용할 수 있다. 엔터프라이즈 개발 용이 개발자가 복잡하고 실수하기 쉬운 Low Level(보안,인증)에 많이 신경 쓰지 않으면서 Business Logic 개발에 전념할 수 있도록 해준다. 오픈소스 Spring은 Open Source 의 장점을 충분히 취하면서 동시에 Open Source 제품의 단점과 한계를 잘 극복한다. Spring Framework 전략 Protable Service Abstraction DI AOP POJO Protable ServiceAbstraction(서비스 추상화)트랜잭션 추상화, OXM 추상화, 데이터 액세스의 Exception 변환기능 등 기술적인 복잡함은 추상화를 통해 Low Level의 기술 구현 부분과 기술을 사용하는 인터페이스로 분리한다. DI(Dependency Injection)Spring은 객체지향에 충실한 설계가 가능하도록 단순한 객체 형태로 개발할 수 있고, DI는 유연하게 확장 가능한 객체를 만들어 두고 그 관계는 외부에서 다이내믹하게 설정해준다. AOP(Aspect Oriented Programming)AOP는 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술 POJO(Plain Old Java Object)POJO는 객체지향 원리에 충실하면서, 특정 환경이나 규약에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 객체 Spring Framework 특징 컨테이너 역할 Spring 컨테이너는 Java 객체의 Life Cycle을 관리하며, Spring 컨테이너로 부터 필요한 객체를 가져와 사용할 수 있다. DI(Dependency Injection)지원 Spring은 설정 파일이나 어노테이션을 통해서 객체간의 의존관계를 설정할 수있다. AOP 지원 Spring은 트랜잭션이나 로깅, 보안과 같이 공통적으로 필요로 하는 모듈들을 실제 핵심 모듈에서 분리해서 적용할 수 있다. POJO 지원 Spring 컨테이너에 저장되는 Java객체는 특정한 인터페이스를 구현하거나, 특정 클래스를 상속받지 않아도 된다. 트랜잭션 처리를 위한 일관된 방법을 지원 JDBC, JTA 등 어떤 트랜잭션을 사용하던 설정을 통해 정보를 관리하므로 트랜잭션 구현에 상관없이 동일한 코드 사용가능 영속성(persistence)과 관련된 다양한 API 지원 Spring은 MyBatis, Hibernate 등 데이터베이스 처리를 위한 ORM(Object Relational Mapping) 프레임워크들과의 연동 지원]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OOP]다형성과 추상화]]></title>
    <url>%2F2019%2F01%2F04%2FOOP-polymorphism%2F</url>
    <content type="text"><![CDATA[객체 지향 프로그래밍 입문 - 최범균님의 인프런 강좌을 보고 작성하였습니다. 다형성(Polymorphism)여러(poly) 모습(morph)을 갖는것 객체 지향에서는 한 객체가 여러 타입을 갖는 것 즉 한 객체가 여러 타입의 기능을 제공 타입 상속으로 다형성 구현 추상화(Abstraction)데이터나 프로세스 등을 의미가 비슷한 개념이나 의미 있는 표현으로 정의하는 과정 두 가지 방식의 추상화 특정한 성질, 공통 성질(일반화) 타입 추상화여러 구현 클래스를 대표하는 상위 타입 도출 흔히 인터페이스 타입으로 추상화 추상화 타입과 구현은 타입 상속으로 연결 추상 타입 사용에 따른 이점 : 유연함추상홪는 의존 대상이 변경하는 시점에추상화 -&gt; 추상 타입 증가 -&gt; 복잡도 증가 아직 존재하지 않는 기능에 대한 이른 추상화는 주의 잘못된 추상화 가능성, 복잡도만증가 실제 변경, 확장이 발생할 때 추상화 시도 추상화를 잘 하려면구현을 한 이유가 무엇 때문인지 생각해야 함]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag> Object-Oriented Programming</tag>
        <tag>Abstraction</tag>
        <tag>Polymorphism</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OOP]상속(Inheritance)이란?]]></title>
    <url>%2F2019%2F01%2F03%2FOOP-Inheritance%2F</url>
    <content type="text"><![CDATA[객체 지향 프로그래밍 입문 - 최범균님의 인프런 강좌을 보고 작성하였습니다. 상속(Inheritance)이란상위 클래스의 기능을 재사용, 확장하는 방법 상속을 통한 기능 재사용시 발생할 수 있는 단점 상위 클래스 변경 어려움 클래스 증가 상속 오용 상속의 단점 해결 방법은 -&gt; 조립!! 조립(Composition)여러 객체를 묶어서 더 복잡한 기능을 제공 보통 필드로 다른 객체를 참조하는 방식으로 조립 또는 객체를 필요 시점에 생성/구함 특정 기능을 재사용 하고 싶다면 특정 객체를 생성하여 사용 상속보다는 조립상속하기에 앞서 조립으로 풀 수 없는지 검토 진짜 하위 타입인 경우에만 상속 사용]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag> Object-Oriented Programming</tag>
        <tag>Inheritance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OOP]캡슐화( encapsulation)란?]]></title>
    <url>%2F2019%2F01%2F02%2FOOP-encapsulation%2F</url>
    <content type="text"><![CDATA[객체 지향 프로그래밍 입문 - 최범균님의 인프런 강좌을 보고 작성하였습니다. 캡슐화(encapsulation)란?캡슐화(encapsulation)는 일반적으로 연관 있는 변수와 함수를 클래스로 묶는 작업을 말한다. 객체가 기능을 어떻게 구현 했는지 외부에 감추는 것 구현에 사용된 데이터의 상세 내용을 외부에 감춤 캡슐화만 잘해도 좋은 코드를 만들 수 있음 정보은닉(Information Hiding) 의미 포함(최근에 포함해서 이야기 많이함) 캡슐화의 장점외부에 영향 없이 객체 내부 구현 변경 가능 클래스 내부 메소드의 구현만 변경하면 되게끔 -&gt; 외부 소스코드의 연쇄적인 변경 x 캡슐화를 잘 할수 있는 규칙!!Tell, Don’t Ask 규칙= 데이터를 달라고 부탁하지 말고 직접 해달라고 하기!Demeter’s Law 규칙 메서드에서 생성한 객체의 메서드만 호출 파라미터로 받은 객체의 메서드만 호출 필드로 참조하는 객체의 메서드만 호출 acc.getExpDate().isAfter(now) -&gt; acc.isExpired();Date date = acc.getExpDate(); date.isAfter(now); -&gt; acc.isValid(now);]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag> Object-Oriented Programming</tag>
        <tag> encapsulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[OOP]객체 지향 프로그램 이란?]]></title>
    <url>%2F2019%2F01%2F01%2FOOP-summary%2F</url>
    <content type="text"><![CDATA[객체 지향 프로그래밍(Object-Oriented Programming) 객체 지향 프로그래밍 이란 기존 절차 지향 프로그래밍 기법만의 유지보수와 기존 소프트웨어 재사용이 어려움에 좀더 나은 프로그램을 만들기 위한 프로그래밍 패러다임이다. 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. 객체 지향 프로그래밍은 인간중심적 프로그래밍 패러다임이다. 유지보수와 재사용성이 높다. software maintenance is not “keep it working like before.” It is “keep being useful in a changing world” -jessica Kerr 객체지향 VS 절차지향객체지향 데이터와 프로시저를 알맞게 묶음 설계에 많은 시간이 투자된다. 유지보수 및 업그레이드가 쉽다. 절차지향 데이터가 여로 프로시저를 이용 객체지향에 비해 쉽다. 이러한 데이터를 공유하는 방식은 변화가 필요할 때 수정을 복잡하게 만든ㄴ다. 객체 객체란 데이터와 기능을 가진 물리적으로 존재하거나 추상적으로 생각 할 수 있는 것. 객체의 핵심 -&gt; 기능제공 객체는 제공하는 기능으로 정의 내부적으로 가진 필드로 정의 하지 않음 클래스(Class)클래스는 특정한 기능을 가진 객체를 생성하게 해주는 설계도라고 할 수 있다.클래스로 부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다. 클래스에는 객체에 포함될 변수와 메소드를 정의해야 한다.]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag> Object-Oriented Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-5.접근제어자]]></title>
    <url>%2F2018%2F03%2F05%2FJava-AccessModifier%2F</url>
    <content type="text"><![CDATA[접근제어자(Access Modifier)접근제어자는 변수나 메소드, 클래스에 대한 접근을 제어하는 문법이다. 접근을 제어하는 이유는 객체가 가진 고유의 멤버 변수값들이 외부에서 잘못 변경되는 것을 막기 위해서 이다. 자바에는 다음과 같은 접근제어자가 있다. private default protected public private접근제어자가 private 으로 설정 되어 있다면 그 변수나 메소드는 해당 클래스에만 접근이 가능하다. 최상위 클래스 선언에서는 private를 사용할 수 없다. default접근제어자를 별도로 설정하지 않는다면 default 접근제어자가 된다. default 접근제어자는 해당 패키지 내에서 접근이 가능하다. protectedprotected 접근제어자는 default 접근제어자와 마찬가지로 동일 패키지내에서 접근이 가능하며 추가적으로 해당 클래스를 상속받은 외부 패키지의 클래스에서도 접근이 가능하다. publicpublic 접근제어자는 모든 클래스에 의해 접근할 수 있다. 즉 접근 제약이 없다. 접근 권한 종류 클래스 하위클래스 동일패키지 모든클래스 private O X X X default O X O X protected O O O X public O O O O public &gt; protected &gt; default &gt; private 꿀팁메소드를 오버라이딩 할 경우 부모 클래스의 메소드의 접근제어자보다 좁아질 수는 없다. 그러나 확장될 수는 있다. private 로 선언된 메소드를 public 으로 오버라이딩하여 모든곳에서 접근 가능하도록 수정이 가능하다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>AccessModifier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-4.String pool]]></title>
    <url>%2F2018%2F03%2F04%2Fjava-string-pool%2F</url>
    <content type="text"><![CDATA[String 에 대한 더 자세한 설명이전 포스트에서 말했듯이 String 객체의 값은 변경할 수 없다.나는 String 객체의 값을 변경 시킬수 있다고 생각하시는 분들을 위해 아래 예제를 통해 설명하겠다.123String a = "Hello";a = a+" World";System.out.println(a); //Hello World 이 예제를 보면 a가 참조하는 메모리의 Hello 라는 값에 World 라는 문자열을 더해서 String 객체의 값을 변경 시킨 것으로 보인다 하지만 실제로는 메모리에 Hello World 를 다시 만들고 a를 다시 참조하게 한다. 간단하게 String 클래스의 immutable(불변) 에 대하여 복습 하였다. String pool 이란??String은 자바 개발자라면 자주 쓰게되는 자료형 이다.간혹 자바에서 ==연산자를 이용해서 문자열을 비교하려고 할때 원치 않는 결과를 얻었던 경험들이 있을 것이다. 스트링은 두가지 생성 방식이 있고 그에 따라 각각 차이점이 존재한다. new 연산자를 이용한 방식 리터럴을 이용한 방식 new를 통해 String을 생성하면 Heap영역에 존재하게 되고 리터럴을 이용할 경우 String constant pool이라는 영역에 존재하게 된다. 예제를 통해 쉽게 설명해 보도록 하겠다. 12345String a = "Hello";String b = "Hello";String c = new String("Hello");System.out.println(a==b); //trueSystem.out.println(a==c); //false 위에 예제의 결과에서 왜 3가지 객체가 다 같은 값을 가지고 있음에도 불구하고 비교 결과가 다른지 의문을 가진 분들이 있을것이다. 우선 == 연산은 값을 비교하는것이 아니라 같은 메모리를 참조하는지 비교하는 것이다. a의 경우 Hello 라는 문자열을 String pool 에 넣게 된다. b의 경우는 이미 같은 문자열이 String pool 에 존재하기에 같은 값을 참조하게 된다. c의 경우에는 new 연산자를 사용하여 새로운 객체를 명시적으로 생성하도록 했기 때문에 String pool이 아닌 다른 주소값을 참조하게된다. 이러한 이유로 위와 같은 결과를 얻을 수 있다. 이 예제를 통해 왜 String 객체의 값을 변경할 수 없어야 하는지 이유도 알 수 있다.만약에 String 객체의 값의 변경이 가능하다면 a의 값을 변경 하였을때 원치 않게 b의 값도 변경될 수 있다. String 객체의 값을 비교하는 equals()equals() 메소드를 이용하여 두 문자열 객체의 실제 값을 비교할 수 있다. 그렇기 때문에 문자열 비교는 equals() 를 사용하는 것이 좋지만 속도적인 부분이나 메모리 부분 때문에 ==을 사용해야한다면 방법은 있다. intern() 메소드를 사용하는 방법이다. intern()12345678910111213141516171819String a = "Hello";String b = new String("Hello");String c = b.intern();System.out.println(a.equal(b)); // trueSystem.out.println(a==c); // true``` **intern()** 메소드를 사용하면 해당 리터럴이 pool 에 존재하는지 화가인하고 존재하면 해당 pool 에 있는 리터럴을 리턴하고 없다면 리터럴을 pool 에 집어넣는다.그렇기 때문에 c의 경우는 String c = "Hello" 로 해석할 수 있고 pool 에 이미 a가 만든 Hello 가 존재하므로 a와 같은 주소를 참조하게 된다.아마도 **intern()** 메소드보다 **equals()** 메소드를 더 많이 사용하게 되겠지만 만약 사용하게 된다면 아래와 같이 사용할 수 있지 않을까 싶다.```javaString id = "user";String compareId = UserDto.getId().intern();if(id == user)&#123; ...&#125; 그냥 이렇게도 사용할 수 있지 않을까 싶어 내가 만든 예시이다. 속도나 메모리를 엄청 신경 써야 하지 않는다면 문자열 비교는 equals()로 습관화 하는것이 좋은 방법일것 같다. String pool 의 위치String pool 은 java 6 버전까지 Perm 영역이었다. 하지만 Perm 영역은 고정된 사이즈이며 Runtime 에 사이즈가 확장되지 않는다 그래서 intern 되는 String 값이 커지면 OutOfMemoryException을 발생시킬 수 있었고 그에따라 java 7 버전에서 heap 영역으로 String pool 의 위치를 변경하였다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>String</tag>
        <tag>StringPool</tag>
        <tag>intern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-3.String, StringBuffer, StringBuilder]]></title>
    <url>%2F2018%2F03%2F03%2Fjava-string%2F</url>
    <content type="text"><![CDATA[String, StringBuffer, StringBuilder 의 특징String, StringBuffer, StringBuilder 이 세가지 클래스들은 모두 문자열 처리를 위한 클래스 이다. 대부분의 자바를 처음 공부하는 사람들은 문자열 처리를 위해서 String 클래스만을 사용하며 조금더 공부하여 StringBuffer 클래스를 알게되면 정확한 차이를 모르는채 성능 향상이라는 이유로 StringBuffer 클래스를 자주 사용한다. 그렇다면 이 세가지 클래스에 정확한 차이점을 알아보고 상황에 맞게 잘 사용해 보도록 하자 String 클래스String 클래스와 다른 2개의 클래스와의 가장 큰 차이점은 String 클래스는 immutable(불변) 하고 StringBuffer, StringBuilder 클래스는 mutable(가변) 한다는 점이다. 이게 무슨 말인지 쉽게 설명 하자면 String 객체는 한번 생성되면 할당된 메모리 공간이 변하지 않는다. +연산자 또는 문자열에 변화를 줘도 메모리 공간이 변하는 것이 아니라 새로운 String 객체를 만든 후, 새 String 객체에 연결된 문자열을 저장하고 그객체를 참조하도록 한다. 변경되기 전의 문자열은 더이상 어느곳에서도 참조하지 않게 되면 가비지 콜렉터(언제 제거될지 모름)에 의해 제거 된다. 이러한 이유로 String 객체는 문자열 연산이 많아질 때 성능이 떨어질 수 밖에 없는 단점이 있다. 그렇다면 왜 이러한 단점을 가지면서도 immutable(불변) 클래스인 String 클래스를 기본 문자열처리 클래스로 정했을까? immutable(불변) 클래스의 가장 큰 장점은 안전하게 공유될 수 있다는 점이다. 즉, 변경은 적고 읽기만 많은 경우, 또는 여러 쓰레드나 객체에서 공유하는 경우, synchronization(동기화)와 같은 특별한 안전장치 없이도 안전하게 공유 될수 있다. 대부분의 문자열이 복잡한 문자열 처리과정보다는 한번 설정된 문자열들을 여러 곳에서 공유하는 경우가 많으므로, 자바에서 기본 문자열을 처리하는 클래스로 String 클래스를 immutable 패턴으로 설정하였다. StringBuffer, StringBuilder 클래스StringBuffer, StringBuilder 클래스는 String 과 다르게 mutable(가변) 클래스이다. 즉 문자열 연산에 있어서 클래스를 한번만 만들고 연산이 필요할 때 크기를 변경시켜 문자열을 변경한다. 이 경우 객체를 새로 생성하지 않는다. 그러므로 문자열 연산이 자주 있을 때 String 클래스 대신 사용하면 성능이 좋다는 장점이 있다. StringBuilder는 JDK 5.0 에서 새로 추가된 클래스이다.두 클래스에서 제공하는 메소드는 동일하다. 차이점은 StringBuffer는 멀티쓰레드환경에서 synchronized키워드가 가능하므로 동기화가 가능하다. 즉, thread-safe하다. StringBuilder는 동기화를 지원하지 않기 때문에 멀티쓰레드환경에서는 적합하지 않다. 대신 StringBuilder가 동기화를 고려하지 않기 때문에 싱글쓰레드 환경에서 StringBuffer에 비해 연산처리가 빠르다. String, StringBuffer, StringBuilder 선택 기준 String 객체는 불변이기 때문에 변하지 않는 문자열은 String을 사용한다. StringBuilder는 비동기방식이기 때문에 Single Thread 환경하에서, 변화되는 문자열의 사용한다. StringBuffer 동기방식으로 저장되기 때문에 멀티쓰레드로 접근하거나 문자열이 변경될 경우에 사용한다. JDK 버전에 따른 차이JDK 1.5버전 이후에는 컴파일 단계에서 String 객체를 사용하더라도 StringBuilder로 컴파일 되도록 변경 되었다. 그렇기 때문에 String 클래스를 활용해도 성능차이가 없어지긴 하였지만 반복 루프를 사용해 문자열을 더할때 객체를 게속 추가하는 사실에는 변함이 없다. 따라서 String 클래스를 쓰는 대신, 스레드와 관련이 있으면 StringBuffer를, 스레드 안전 여부와 상관이 없으면 StringBuilder를 사용하는 것을 권장한다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-2.자바 메모리 구조]]></title>
    <url>%2F2018%2F03%2F02%2FJava-runtime-data-area%2F</url>
    <content type="text"><![CDATA[Runtime Data Area JVM이 프로그램을 수행하기 위해 운영체제로부터 할당 받는 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 이 영역은 각각의 목젝에 따라 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있다. Method Area(메소드 영역) 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 메소드 정보, Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수등이 생성되는 영역이다. 프로그램이 실행되면 모든 코드가 저장되어 있는 상태가 아니다. new 키워드를 통해 객체가 동적으로 생성되기 이전에는 텍스트 일 뿐이다. 객체 생성 후에 메소드를 실행하게 되면 해당 클래스 코드에 대한 정보를 Method Area에 저장 하게 된다. Heap area(힙 영역) 사용자가 관리하는 인스턴스가 생성되는 공간으로 객체를 동적으로 생성하면 인스턴스가 Heap 영역의 메모리에 할당되어 사용되어진다. 프로그램은 시작될 때 미리 Heap 영역을 많이 할당해 놓으며 인스턴스와 인스턴스 변수가 저장된다. 레퍼런스 변수의 경우 Heap에 인스턴스가 저장 되는것이 아니라 포인터가 저장된다. 메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다. Stack area (스택 영역) 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다. int x = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 x라고 잡아두고 그 메모리 영역에 값이 10이 들어간다. 즉, 스택에 메모리에 이름이 x라고 붙여주고 값이 10인 메모리 공간을 만든다. Animal dog = new Animal(); 이라는 코드를 작성했다면 Animal dog은 스택 영역에 생성되고 new로 생성된 Animal클래스의 인스턴스는 힙 영역에 생성된다. 스택영역에 생성된 dog의 값으로 힙 영역의 주소값을 가지고 있다. 즉 스택 영역에 생성된 dog가 힙 영역에 생성된 객체를 참조하고 있는 것이다. PC Register (PC 레지스터) PC Registers는 Thread가 생성될 때 마다 생기는 공간으로 Thread가 어떠한 명령을 실행하게 될지에 대한 부분을 기록을 한다. JVM은 Stacks-Base 방식으로 작동 하는데, JVM은 CPU에 직접 Instruction을 수행하지 않고, Stack에서 Operand를 뽑아내 이를 별도의 메모리 공간에 저장하는 방식을 취하는데, 이러한 메모리 공간을 PC Registers라고 한다. Native method stack 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다. 보통 C/C++등의 코드를 수행하기 위한 스택이다. JNI를 통해 표준에 가까운 방식으로 구현이 가능하다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-1.자바란?]]></title>
    <url>%2F2018%2F03%2F01%2FJava-summary%2F</url>
    <content type="text"><![CDATA[자바 언어의 이해자바 자바는 썬 마이크로시스템즈에서 제임스 고슬링이 다른 연구원들과 함꼐 고안한 오크(Oak)라는 언어에서 시작되었다. 오크는 가전제품에서 사용될 목적이었으나, 인터넷이 발전하면서 인터넷 친화적 언어로 사용되었고 1995년 ‘자바’로 이름을 변경하였다. 1995년~1999년까지는 윈도우 프로그램 개발이 주류여서 C++언어에 비해 자바는 열세였지만 1999년도부터 자바는 활성화 되었고 현재 자바는 IT기술 전반에서 가장 널리 사용하는 프로그래밍 언어가 되었다. 자바 프로그래밍자바의 프로그램의 실행 과정은 다음과 같다. 자바 컴파일러(Java compiler) Java를 가지고 작성한 자바 소스 코드를 자바 가상 머신이 이해할 수 있는 자바 바이트 코드로 변환한다. 자바 컴파일러는 자바를 설치하면 javac.exe라는 실행 파일 형태로 설치 된다. 자바 바이트 코드(Java bytecode) 자바 바이트 코드란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다. 자바 컴파일러에 의해서 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불린다. 자바 바이트 코드의 확장자는 .class 이다. 자바 바이트 코드는 자바 가상 머신이 설치되어 있다면 어떤 운영체제에서라도 실행 될 수 있다.JVM JVM이란 JAVA Virtual Machine의 약자로 자바 가성 머신을 줄여 부르는 용어이다. 자바 컴파일러를 통해 바이트코드를 생성한다. 바이트코드는 하드웨어에 종속적이지 않은 중간 파일로, JVM은 이러한 바이트코드를 실행 시키기 위한 가상의 기계라고 할 수 있다. JVM이 설치되어 있으면 서로 다른 기기나 운영체제에서 동일하게 프로그램을 실행할 수 있다. JVM의 구성자바 가상 머신(JVM)은 다음과 같이 구성된다. 자바 인터프리터(interpreter) 클래스 로더(class loader) JIT 컴파일러 (Just-In-Time compiler) 가비지 컬렉터(garbage collector) 자바 컴파일러에 의해 변환된 자바 바이트 코드를 읽고 해석하는 역할을 하는 것이 자바 인터프리터(interpreter)이다. 자바는 동적으로 클래스를 읽어오므로, 프로그램이 실행 중인 런타임에서야 모든 코드가 자바 가상머신과 연결된다. 이렇게 동적으로 클래스를 로딩해주는 역할을 하는 것이 바로 클래스 로더(class loader)이다. JIT 컴파일러 (Just-In-Time compiler)란 프로그램이 실행 중인 런타임에 실제 기계어로 변환해 주는 컴파일러를 의미한다. 동적 번역(dynamic translation)이라고도 불리는 이 기법은 프로그램의 실행 속도를 향상시키기 위해 개발되었습니다.즉, JIT 컴파일러는 자바 컴파일러가 생성한 자바 바이트 코드를 런타임에 바로 기계어로 변환하는데 사용된다. 자바 가상 머신은 가비지 컬렉터(garbage collector)를 이용하여 더는 사용하지 않는 메모리를 자동으로 회수해 준다. 따라서 개발자가 따로 메모리를 관리하지 않아도 되므로, 더욱 손쉽게 프로그래밍을 할 수 있도록 도와준다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
