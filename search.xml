<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[REST API 만들기-1]]></title>
    <url>%2F2019%2F01%2F24%2FREST-API-1%2F</url>
    <content type="text"><![CDATA[스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. “Event” REST API 만들기-1추가할 의존성 및 JDK 버전 Web JPA HATEOAS REST Docs H2 PostgreSQL Lombok JDK 11시작하기Event 클래스 만들기.패키지를 하나 만들고 그안에 Event 클래스를 생성한다.이벤트 클래스는 나중에 DB의 테이블과 매칭될 Entity 클래스 이다.123456789101112public class Event &#123; private String name; private String description; private LocalDateTime beginEnrollmentDateTime; private LocalDateTime closeEnrollmentDateTime; private LocalDateTime beginEventDateTime; private LocalDateTime endEventDateTime; private String location; private int basePrice; private int maxPrice; private int limitOfEnrollment;&#125; EventStatus enum 클래스 생성123public enum EventStatus &#123; DRAFT, PUBLISHED, BEGEAN_ENROLLMENT;&#125; Event 클래스에 lombok 어노테이션 추가12@Builder @AllArgsConstructor @NoArgsConstructor@Getter @Setter @EqualsAndHashCode(of="id") Test 클래스를 만들어 junit 테스트12345678910111213141516171819202122232425@Testpublic void builder()&#123; Event event = Event.builder() .name("inflearn") .description("rst API") .build(); assertThat(event).isNotNull();&#125;@Testpublic void JavaBean()&#123; //Given String name = "Event"; String description = "Spring"; //When Event event = new Event(); event.setName("Event"); event.setDescription("Spring"); //Then assertThat(event.getName()).isEqualTo(name); assertThat(event.getDescription()).isEqualTo(description);&#125; Lombok 과 AssertJ의 추가적인 설명 LombokAssertJ]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spring-library]AssertJ란?]]></title>
    <url>%2F2019%2F01%2F23%2FSpring-AssertJ%2F</url>
    <content type="text"><![CDATA[AsertJ란? java test를 위해 좀 더 풍부한 문법을 제공하고 메서드 체이닝을 통해 직관적인 테스트 흐름을 작성할 수 있도록 개발된 오픈소스 라이브러리이다. 최근 junit에 필수로 사용되고 있는 추세이다. 공식홈페이지 시작하기라이브러리 의존성 설정Maven1234567&lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;!-- use 2.9.1 for Java 7 projects --&gt; &lt;version&gt;3.11.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Gradle1testCompile("org.assertj:assertj-core:3.11.1") 또는 Java 7 프로젝트의 경우 버전 2.9.11testCompile("org.assertj:assertj-core:2.9.1") AssertJ 메소드 임포트1import static org.assertj.core.api.Assertions.*; 실제 사용1assertThat(objectUnderTest). // code completion -&gt; assertions specific to objectUnderTest 모든 테스트 코드는 assertThat() 메소드에서 시작한다. ###문자열 테스트12345678assertThat("Hello, world! Nice to meet you.") // 주어진 "Hello, world! Nice to meet you."라는 문자열은 .isNotEmpty() // 비어있지 않고 .contains("Nice") // "Nice"를 포함하고 .contains("world") // "world"도 포함하고 .doesNotContain("ZZZ") // "ZZZ"는 포함하지 않으며 .startsWith("Hell") // "Hell"로 시작하고 .endsWith("u.") // "u."로 끝나며 .isEqualTo("Hello, world! Nice to meet you."); // "Hello, world! Nice to meet you."과 일치합니다. 숫자 테스트1234567assertThat(3.14d) // 주어진 3.14라는 숫자는 .isPositive() // 양수이고 .isGreaterThan(3) // 3보다 크며 .isLessThan(4) // 4보다 작습니다 .isEqualTo(3, offset(1d)) // 오프셋 1 기준으로 3과 같고 .isEqualTo(3.1, offset(0.1d)) // 오프셋 0.1 기준으로 3.1과 같으며 .isEqualTo(3.14); // 오프셋 없이는 3.14와 같습니다]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>library</tag>
        <tag>Test</tag>
        <tag>AssertJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST API란]]></title>
    <url>%2F2019%2F01%2F23%2FREST-API%2F</url>
    <content type="text"><![CDATA[스프링 기반 REST API 개발 -백기선님 인프런 강좌를 보고 작성하였습니다. API Application Programming Interface 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. REST REpresentational State Treansfer 인터넷 상의 시스템 간의 상호 운용성(Interoperability)을 제공하는 방법중 하나 시스템 제각각의 독립적인 진화를 보장하기 위한 방법 REST API : REST 아키텍처 스타일을 따르는 API 그런 REST API로 괜찮은가 그런 REST API로 괜찮은가 - 이응준님 강연을 보고 작성하였습니다. 오늘날 대부분의 “REST API”는 사실 REST를 따르지 않고 있다. REST의 제약조건 중에서 특히 Self-descriptive와 HATEOAS를 잘 만족하지 못한다. REST를 따르겠다면, Self-descriptive와 HATEOAS를 만족시켜야한다. Self-descriptive는 custom media type이나 profile link relation 등으로 만족시킬 수 있다. HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.Self descriptive message 메세지 스스로 메세지에 대한 설명이 가능해야 한다. 이렇지 않으면 API문서를 항상 만들어야 한다. API만 보고 의미를 알 수 없기 때문이다. Self descriptive message를 달성하기 위한 방법 미디어 타입을 IANA에 등록하고 그 미디어 타입을 리소스 리턴할 때 Content-Type으로 사용한다. ProFile 의미가 뭔지 정보가 담긴 문서 링크 헤더를 추가한다. HATEOAS 하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 하며 링크 정보를 동적으로 바꿀 수 있다. HATEOS는 애플리케이션 상태 전이의 late binding을 가능하게 하기 때문에 필요하다.어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이될 수 있는 상태가 결정된다. 링크는 동적으로 변경될 수 있다. 언제나 서버가 마음대로 바꿀 수 있음.HATEOAS를 달성하기 위한 방법 데이터 링크 제공 HTTP 헤더에 Location, Link를 활용하는 방법]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-3.String, StringBuffer, StringBuilder]]></title>
    <url>%2F2018%2F03%2F03%2Fjava-string%2F</url>
    <content type="text"><![CDATA[String, StringBuffer, StringBuilder 의 특징String, StringBuffer, StringBuilder 이 세가지 클래스들은 모두 문자열 처리를 위한 클래스 이다. 대부분의 자바를 처음 공부하는 사람들은 문자열 처리를 위해서 String 클래스만을 사용하며 조금더 공부하여 StringBuffer 클래스를 알게되면 정확한 차이를 모르는채 성능 향상이라는 이유로 StringBuffer 클래스를 자주 사용한다. 그렇다면 이 세가지 클래스에 정확한 차이점을 알아보고 상황에 맞게 잘 사용해 보도록 하자 String 클래스String 클래스와 다른 2개의 클래스와의 가장 큰 차이점은 String 클래스는 immutable(불변) 하고 StringBuffer, StringBuilder 클래스는 mutable(가변) 한다는 점이다. 이게 무슨 말인지 쉽게 설명 하자면 String 객체는 한번 생성되면 할당된 메모리 공간이 변하지 않는다. +연산자 또는 문자열에 변화를 줘도 메모리 공간이 변하는 것이 아니라 새로운 String 객체를 만든 후, 새 String 객체에 연결된 문자열을 저장하고 그객체를 참조하도록 한다. 변경되기 전의 문자열은 더이상 어느곳에서도 참조하지 않게 되면 가비지 콜렉터(언제 제거될지 모름)에 의해 제거 된다. 이러한 이유로 String 객체는 문자열 연산이 많아질 때 성능이 떨어질 수 밖에 없는 단점이 있다. 그렇다면 왜 이러한 단점을 가지면서도 immutable(불변) 클래스인 String 클래스를 기본 문자열처리 클래스로 정했을까? immutable(불변) 클래스의 가장 큰 장점은 안전하게 공유될 수 있다는 점이다. 즉, 변경은 적고 읽기만 많은 경우, 또는 여러 쓰레드나 객체에서 공유하는 경우, synchronization(동기화)와 같은 특별한 안전장치 없이도 안전하게 공유 될수 있다. 대부분의 문자열이 복잡한 문자열 처리과정보다는 한번 설정된 문자열들을 여러 곳에서 공유하는 경우가 많으므로, 자바에서 기본 문자열을 처리하는 클래스로 String 클래스를 immutable 패턴으로 설정하였다. StringBuffer, StringBuilder 클래스StringBuffer, StringBuilder 클래스는 String 과 다르게 mutable(가변) 클래스이다. 즉 문자열 연산에 있어서 클래스를 한번만 만들고 연산이 필요할 때 크기를 변경시켜 문자열을 변경한다. 이 경우 객체를 새로 생성하지 않는다. 그러므로 문자열 연산이 자주 있을 때 String 클래스 대신 사용하면 성능이 좋다는 장점이 있다. StringBuilder는 JDK 5.0 에서 새로 추가된 클래스이다.두 클래스에서 제공하는 메소드는 동일하다. 차이점은 StringBuffer는 멀티쓰레드환경에서 synchronized키워드가 가능하므로 동기화가 가능하다. 즉, thread-safe하다. StringBuilder는 동기화를 지원하지 않기 때문에 멀티쓰레드환경에서는 적합하지 않다. 대신 StringBuilder가 동기화를 고려하지 않기 때문에 싱글쓰레드 환경에서 StringBuffer에 비해 연산처리가 빠르다. String, StringBuffer, StringBuilder 선택 기준 String 객체는 불변이기 때문에 변하지 않는 문자열은 String을 사용한다. StringBuilder는 비동기방식이기 때문에 Single Thread 환경하에서, 변화되는 문자열의 사용한다. StringBuffer 동기방식으로 저장되기 때문에 멀티쓰레드로 접근하거나 문자열이 변경될 경우에 사용한다. JDK 버전에 따른 차이JDK 1.5버전 이후에는 컴파일 단계에서 String 객체를 사용하더라도 StringBuilder로 컴파일 되도록 변경 되었다. 그렇기 때문에 String 클래스를 활용해도 성능차이가 없어지긴 하였지만 반복 루프를 사용해 문자열을 더할때 객체를 게속 추가하는 사실에는 변함이 없다. 따라서 String 클래스를 쓰는 대신, 스레드와 관련이 있으면 StringBuffer를, 스레드 안전 여부와 상관이 없으면 StringBuilder를 사용하는 것을 권장한다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-2.자바 메모리 구조]]></title>
    <url>%2F2018%2F03%2F02%2FJava-runtime-data-area%2F</url>
    <content type="text"><![CDATA[Runtime Data Area JVM이 프로그램을 수행하기 위해 운영체제로부터 할당 받는 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 이 영역은 각각의 목젝에 따라 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있다. Method Area(메소드 영역) 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 메소드 정보, Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수등이 생성되는 영역이다. 프로그램이 실행되면 모든 코드가 저장되어 있는 상태가 아니다. new 키워드를 통해 객체가 동적으로 생성되기 이전에는 텍스트 일 뿐이다. 객체 생성 후에 메소드를 실행하게 되면 해당 클래스 코드에 대한 정보를 Method Area에 저장 하게 된다. Heap area(힙 영역) 사용자가 관리하는 인스턴스가 생성되는 공간으로 객체를 동적으로 생성하면 인스턴스가 Heap 영역의 메모리에 할당되어 사용되어진다. 프로그램은 시작될 때 미리 Heap 영역을 많이 할당해 놓으며 인스턴스와 인스턴스 변수가 저장된다. 레퍼런스 변수의 경우 Heap에 인스턴스가 저장 되는것이 아니라 포인터가 저장된다. 메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다. Stack area (스택 영역) 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다. int x = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 x라고 잡아두고 그 메모리 영역에 값이 10이 들어간다. 즉, 스택에 메모리에 이름이 x라고 붙여주고 값이 10인 메모리 공간을 만든다. Animal dog = new Animal(); 이라는 코드를 작성했다면 Animal dog은 스택 영역에 생성되고 new로 생성된 Animal클래스의 인스턴스는 힙 영역에 생성된다. 스택영역에 생성된 dog의 값으로 힙 영역의 주소값을 가지고 있다. 즉 스택 영역에 생성된 dog가 힙 영역에 생성된 객체를 참조하고 있는 것이다. PC Register (PC 레지스터) PC Registers는 Thread가 생성될 때 마다 생기는 공간으로 Thread가 어떠한 명령을 실행하게 될지에 대한 부분을 기록을 한다. JVM은 Stacks-Base 방식으로 작동 하는데, JVM은 CPU에 직접 Instruction을 수행하지 않고, Stack에서 Operand를 뽑아내 이를 별도의 메모리 공간에 저장하는 방식을 취하는데, 이러한 메모리 공간을 PC Registers라고 한다. Native method stack 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다. 보통 C/C++등의 코드를 수행하기 위한 스택이다. JNI를 통해 표준에 가까운 방식으로 구현이 가능하다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리]]></title>
    <url>%2F2018%2F03%2F01%2FJava-summary%2F</url>
    <content type="text"><![CDATA[자바 언어의 이해자바 자바는 썬 마이크로시스템즈에서 제임스 고슬링이 다른 연구원들과 함꼐 고안한 오크(Oak)라는 언어에서 시작되었다. 오크는 가전제품에서 사용될 목적이었으나, 인터넷이 발전하면서 인터넷 친화적 언어로 사용되었고 1995년 ‘자바’로 이름을 변경하였다. 1995년~1999년까지는 윈도우 프로그램 개발이 주류여서 C++언어에 비해 자바는 열세였지만 1999년도부터 자바는 활성화 되었고 현재 자바는 IT기술 전반에서 가장 널리 사용하는 프로그래밍 언어가 되었다. 자바 프로그래밍자바의 프로그램의 실행 과정은 다음과 같다. 자바 컴파일러(Java compiler) Java를 가지고 작성한 자바 소스 코드를 자바 가상 머신이 이해할 수 있는 자바 바이트 코드로 변환한다. 자바 컴파일러는 자바를 설치하면 javac.exe라는 실행 파일 형태로 설치 된다. 자바 바이트 코드(Java bytecode) 자바 바이트 코드란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다. 자바 컴파일러에 의해서 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불린다. 자바 바이트 코드의 확장자는 .class 이다. 자바 바이트 코드는 자바 가상 머신이 설치되어 있다면 어떤 운영체제에서라도 실행 될 수 있다.JVM JVM이란 JAVA Virtual Machine의 약자로 자바 가성 머신을 줄여 부르는 용어이다. 자바 컴파일러를 통해 바이트코드를 생성한다. 바이트코드는 하드웨어에 종속적이지 않은 중간 파일로, JVM은 이러한 바이트코드를 실행 시키기 위한 가상의 기계라고 할 수 있다. JVM이 설치되어 있으면 서로 다른 기기나 운영체제에서 동일하게 프로그램을 실행할 수 있다. JVM의 구성자바 가상 머신(JVM)은 다음과 같이 구성된다. 자바 인터프리터(interpreter) 클래스 로더(class loader) JIT 컴파일러 (Just-In-Time compiler) 가비지 컬렉터(garbage collector) 자바 컴파일러에 의해 변환된 자바 바이트 코드를 읽고 해석하는 역할을 하는 것이 자바 인터프리터(interpreter)이다. 자바는 동적으로 클래스를 읽어오므로, 프로그램이 실행 중인 런타임에서야 모든 코드가 자바 가상머신과 연결된다. 이렇게 동적으로 클래스를 로딩해주는 역할을 하는 것이 바로 클래스 로더(class loader)이다. JIT 컴파일러 (Just-In-Time compiler)란 프로그램이 실행 중인 런타임에 실제 기계어로 변환해 주는 컴파일러를 의미한다. 동적 번역(dynamic translation)이라고도 불리는 이 기법은 프로그램의 실행 속도를 향상시키기 위해 개발되었습니다.즉, JIT 컴파일러는 자바 컴파일러가 생성한 자바 바이트 코드를 런타임에 바로 기계어로 변환하는데 사용된다. 자바 가상 머신은 가비지 컬렉터(garbage collector)를 이용하여 더는 사용하지 않는 메모리를 자동으로 회수해 준다. 따라서 개발자가 따로 메모리를 관리하지 않아도 되므로, 더욱 손쉽게 프로그래밍을 할 수 있도록 도와준다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
