<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[REST API란]]></title>
    <url>%2F2019%2F01%2F23%2FREST-API%2F</url>
    <content type="text"><![CDATA[API Application Programming Interface 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. REST REpresentational State Treansfer 인터넷 상의 시스템 간의 상호 운용성(Interoperability)을 제공하는 방법중 하나 시스템 제각각의 독립적인 진화를 보장하기 위한 방법 REST API : REST 아키텍처 스타일을 따르는 API 그런 REST API로 괜찮은가 그런 REST API로 괜찮은가 - 이응준님 강연을 보고 작성하였습니다. 오늘날 대부분의 “REST API”는 사실 REST를 따르지 않고 있다. REST의 제약조건 중에서 특히 Self-descriptive와 HATEOAS를 잘 만족하지 못한다. REST를 따르겠다면, Self-descriptive와 HATEOAS를 만족시켜야한다. Self-descriptive는 custom media type이나 profile link relation 등으로 만족시킬 수 있다. HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.Self descriptive message 메세지 스스로 메세지에 대한 설명이 가능해야 한다. 이렇지 않으면 API문서를 항상 만들어야 한다. API만 보고 의미를 알 수 없기 때문이다. Self descriptive message를 달성하기 위한 방법 미디어 타입을 IANA에 등록하고 그 미디어 타입을 리소스 리턴할 때 Content-Type으로 사용한다. ProFile 의미가 뭔지 정보가 담긴 문서 링크 헤더를 추가한다. HATEOAS 하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 하며 링크 정보를 동적으로 바꿀 수 있다. HATEOS는 애플리케이션 상태 전이의 late binding을 가능하게 하기 때문에 필요하다.어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이될 수 있는 상태가 결정된다. 링크는 동적으로 변경될 수 있다. 언제나 서버가 마음대로 바꿀 수 있음.HATEOAS를 달성하기 위한 방법 데이터 링크 제공 HTTP 헤더에 Location, Link를 활용하는 방법]]></content>
      <categories>
        <category>RESTAPI</category>
      </categories>
      <tags>
        <tag>RESTAPI</tag>
        <tag>REST</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리-2.자바 메모리 구조]]></title>
    <url>%2F2018%2F03%2F02%2FJava-runtime-data-area%2F</url>
    <content type="text"><![CDATA[Runtime Data Area JVM이 프로그램을 수행하기 위해 운영체제로부터 할당 받는 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 이 영역은 각각의 목젝에 따라 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있다. Method Area(메소드 영역) 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 메소드 정보, Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수등이 생성되는 영역이다. 프로그램이 실행되면 모든 코드가 저장되어 있는 상태가 아니다. new 키워드를 통해 객체가 동적으로 생성되기 이전에는 텍스트 일 뿐이다. 객체 생성 후에 메소드를 실행하게 되면 해당 클래스 코드에 대한 정보를 Method Area에 저장 하게 된다. Heap area(힙 영역) 사용자가 관리하는 인스턴스가 생성되는 공간으로 객체를 동적으로 생성하면 인스턴스가 Heap 영역의 메모리에 할당되어 사용되어진다. 프로그램은 시작될 때 미리 Heap 영역을 많이 할당해 놓으며 인스턴스와 인스턴스 변수가 저장된다. 레퍼런스 변수의 경우 Heap에 인스턴스가 저장 되는것이 아니라 포인터가 저장된다. 메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다. Stack area (스택 영역) 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다. int x = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 x라고 잡아두고 그 메모리 영역에 값이 10이 들어간다. 즉, 스택에 메모리에 이름이 x라고 붙여주고 값이 10인 메모리 공간을 만든다. Animal dog = new Animal(); 이라는 코드를 작성했다면 Animal dog은 스택 영역에 생성되고 new로 생성된 Animal클래스의 인스턴스는 힙 영역에 생성된다. 스택영역에 생성된 dog의 값으로 힙 영역의 주소값을 가지고 있다. 즉 스택 영역에 생성된 dog가 힙 영역에 생성된 객체를 참조하고 있는 것이다. PC Register (PC 레지스터) PC Registers는 Thread가 생성될 때 마다 생기는 공간으로 Thread가 어떠한 명령을 실행하게 될지에 대한 부분을 기록을 한다. JVM은 Stacks-Base 방식으로 작동 하는데, JVM은 CPU에 직접 Instruction을 수행하지 않고, Stack에서 Operand를 뽑아내 이를 별도의 메모리 공간에 저장하는 방식을 취하는데, 이러한 메모리 공간을 PC Registers라고 한다. Native method stack 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다. 보통 C/C++등의 코드를 수행하기 위한 스택이다. JNI를 통해 표준에 가까운 방식으로 구현이 가능하다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JAVA]자바의 기본 개념 정리]]></title>
    <url>%2F2018%2F03%2F01%2FJava-summary%2F</url>
    <content type="text"><![CDATA[자바 언어의 이해자바 자바는 썬 마이크로시스템즈에서 제임스 고슬링이 다른 연구원들과 함꼐 고안한 오크(Oak)라는 언어에서 시작되었다. 오크는 가전제품에서 사용될 목적이었으나, 인터넷이 발전하면서 인터넷 친화적 언어로 사용되었고 1995년 ‘자바’로 이름을 변경하였다. 1995년~1999년까지는 윈도우 프로그램 개발이 주류여서 C++언어에 비해 자바는 열세였지만 1999년도부터 자바는 활성화 되었고 현재 자바는 IT기술 전반에서 가장 널리 사용하는 프로그래밍 언어가 되었다. 자바 프로그래밍자바의 프로그램의 실행 과정은 다음과 같다. 자바 컴파일러(Java compiler) Java를 가지고 작성한 자바 소스 코드를 자바 가상 머신이 이해할 수 있는 자바 바이트 코드로 변환한다. 자바 컴파일러는 자바를 설치하면 javac.exe라는 실행 파일 형태로 설치 된다. 자바 바이트 코드(Java bytecode) 자바 바이트 코드란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다. 자바 컴파일러에 의해서 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불린다. 자바 바이트 코드의 확장자는 .class 이다. 자바 바이트 코드는 자바 가상 머신이 설치되어 있다면 어떤 운영체제에서라도 실행 될 수 있다.JVM JVM이란 JAVA Virtual Machine의 약자로 자바 가성 머신을 줄여 부르는 용어이다. 자바 컴파일러를 통해 바이트코드를 생성한다. 바이트코드는 하드웨어에 종속적이지 않은 중간 파일로, JVM은 이러한 바이트코드를 실행 시키기 위한 가상의 기계라고 할 수 있다. JVM이 설치되어 있으면 서로 다른 기기나 운영체제에서 동일하게 프로그램을 실행할 수 있다. JVM의 구성자바 가상 머신(JVM)은 다음과 같이 구성된다. 자바 인터프리터(interpreter) 클래스 로더(class loader) JIT 컴파일러 (Just-In-Time compiler) 가비지 컬렉터(garbage collector) 자바 컴파일러에 의해 변환된 자바 바이트 코드를 읽고 해석하는 역할을 하는 것이 자바 인터프리터(interpreter)이다. 자바는 동적으로 클래스를 읽어오므로, 프로그램이 실행 중인 런타임에서야 모든 코드가 자바 가상머신과 연결된다. 이렇게 동적으로 클래스를 로딩해주는 역할을 하는 것이 바로 클래스 로더(class loader)이다. JIT 컴파일러 (Just-In-Time compiler)란 프로그램이 실행 중인 런타임에 실제 기계어로 변환해 주는 컴파일러를 의미한다. 동적 번역(dynamic translation)이라고도 불리는 이 기법은 프로그램의 실행 속도를 향상시키기 위해 개발되었습니다.즉, JIT 컴파일러는 자바 컴파일러가 생성한 자바 바이트 코드를 런타임에 바로 기계어로 변환하는데 사용된다. 자바 가상 머신은 가비지 컬렉터(garbage collector)를 이용하여 더는 사용하지 않는 메모리를 자동으로 회수해 준다. 따라서 개발자가 따로 메모리를 관리하지 않아도 되므로, 더욱 손쉽게 프로그래밍을 할 수 있도록 도와준다.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
